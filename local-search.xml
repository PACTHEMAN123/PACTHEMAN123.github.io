<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络：网络层</title>
    <link href="/2024/09/26/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2024/09/26/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h1 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h1><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><p>网络层可以被分为<strong>数据平面</strong>和<strong>控制平面</strong>。数据平面的功能可以理解为每台路由器的控制功能，控制平面可以理解为对整个网络的控制。在进入正式的讨论之前，还需要区分两个概念：</p><ul><li><strong>转发</strong>：路由器将输入链路的分组正确地移动到输出链路（或者阻挡）。</li><li><strong>路由选择</strong>：网络层决定分组所采用的路由和路径，使用合适的<strong>路由选择算法</strong>来决定一个分组流动的路径。</li></ul><hr><blockquote><p><em><strong>PART1：数据平面</strong></em></p></blockquote><h2 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h2><p>Internet提供<strong>尽力而为服务</strong>，大概意思是：<em>我尽力了，但我不保证任何东西</em>。</p><p>基于链路层帧的字段来做转发决定的分组交换机，称为<strong>链路层交换机</strong>，其他分组交换机称为<strong>路由器</strong>，为网络层的设备。</p><h1 id="路由机"><a href="#路由机" class="headerlink" title="路由机"></a>路由机</h1><p>一台路由机一般包含下面的部分：</p><ul><li>输入端口</li><li>交换结构</li><li>输出端口</li><li>路由选择处理器</li></ul><h2 id="输入端口处理"><a href="#输入端口处理" class="headerlink" title="输入端口处理"></a>输入端口处理</h2><p>在输入端口，路由器根据<strong>转发表</strong>来查找输出端口，使得到达的分组根据交换结构到达输出端口。转发表复制于路由选择处理器。一种比较简单的转发表是基于地址的前缀进行匹配（因为显然输出端口的数量有限）。查表的操作需要硬件和快速查找算法的搭配。通过查表确定输出端口之后，分组就可以进入交换结构，但也有可能因为排队而导致该分组阻塞。</p><h2 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h2><p>交换有几种方式可以完成：</p><h3 id="经内存交换"><a href="#经内存交换" class="headerlink" title="经内存交换"></a>经内存交换</h3><p>路由器就如同一个计算机，cpu控制输出端口和输入端口的交换，具体地，通过内存来交换。显然这种方法极有可能导致传输速度受到<strong>内存带宽</strong>的限制。</p><h3 id="经总线交换"><a href="#经总线交换" class="headerlink" title="经总线交换"></a>经总线交换</h3><p>输入端口为分组加上一个标签，将分组通过总线发送给每一个输出端口，但只有对应标签的输出端口可以收到，在输出端口处再去掉该标签。每个分组共用一条总线：交换受总线带宽速率的限制。</p><h3 id="经互联网络交换"><a href="#经互联网络交换" class="headerlink" title="经互联网络交换"></a>经互联网络交换</h3><p>如<strong>纵横式交换机</strong>，可以并发转发多个分组，为<strong>非阻塞的</strong>。当然，如果两个不同输入端口的分组的输出端口原因的话，还是需要等待</p><h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><p>取出输出端口的内存中的分组并发送到输出链路中。</p><h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>从上文可知，排队可能出现在输入端口和输出端口处。</p><p>在输入端口处，分组需要等待前面的分组发送，被称为<strong>线路前部(HOL)阻塞</strong>。</p><p>在输出端口处，分组需要等待输出链路传播。在此处可能产生排队，当缓存超过内存时，需要对队列进行处理（<strong>主动队列管理(AQM)算法</strong>）。</p><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><p>对于上面提到的，在输出端口的队列，我们需要有一定的排队规则，使得队列中的分组有不同的优先级，即决定谁先输出。以下为几种调度的规则：</p><ul><li><strong>FIFO</strong>：先进先出，超过内存的分组直接丢弃。这种方法确保了分组从输入端口到输出链路的次序</li><li><strong>priority queuing</strong>：优先权排队，到达输出链路的分组会被分类放入不同优先级的队列。比如携带网络管理信息的分组、基于IP的实时话音分组等可能有更高的优先级。在同一优先级的队列中，采用FIFO。</li><li><strong>round robin queuing discipline</strong>：循环排队规则，分组像使用优先权排队一样被放入不同的队列，但每个队列并不存在真正的优先级，循环调度器为每条队列轮流提供服务。一种较为通用的循环排队为<strong>加权公平排队</strong>。</li></ul><h1 id="网际协议-IP"><a href="#网际协议-IP" class="headerlink" title="网际协议(IP)"></a>网际协议(IP)</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="数据报格式"><a href="#数据报格式" class="headerlink" title="数据报格式"></a>数据报格式</h3><p>IPv4（Internet Protocol Version 4）的数据格式通常被称为“IPv4数据报”或“IPv4包”，它包括以下几个主要部分：</p><h4 id="首部（Header）"><a href="#首部（Header）" class="headerlink" title="首部（Header）"></a>首部（Header）</h4><p>   IPv4数据报的首部部分长度至少为20字节，最多可扩展到60字节。首部用于传递与路由和传输数据相关的控制信息。以下是IPv4首部各字段的简要说明：</p><ul><li><strong>版本（Version）：</strong> 4位，表示协议的版本号，对于IPv4，值为4。</li><li><strong>首部长度（IHL, Internet Header Length）：</strong> 4位，表示首部的长度，以4字节为单位，最小值为5（表示20字节的基本首部），最大值为15（表示60字节的最大首部）。</li><li><strong>服务类型（Type of Service, ToS）：</strong> 8位，用于指定优先级和服务质量（QoS）。</li><li><strong>总长度（Total Length）：</strong> 16位，表示整个数据报的长度（包括首部和数据），单位为字节，最大长度为65535字节。</li><li><strong>标识（Identification）：</strong> 16位，唯一标识数据报的ID，用于数据报的重组。</li><li><strong>标志（Flags）：</strong> 3位，用于控制分片，其中有一个常见的DF（Don’t Fragment）标志。</li><li><strong>片偏移（Fragment Offset）：</strong> 13位，指示数据报片的偏移，用于重组分片后的数据报。</li><li><strong>生存时间（TTL, Time to Live）：</strong> 8位，数据报在网络中的跳数限制，每经过一个路由器，该值会减1，值为0时数据报被丢弃。</li><li><strong>协议（Protocol）：</strong> 8位，表示上层协议的类型，如TCP（6）、UDP（17）。</li><li><strong>首部校验和（Header Checksum）：</strong> 16位，用于检验IPv4首部的完整性和有效性。</li><li><strong>源IP地址（Source Address）：</strong> 32位，发送方的IP地址。</li><li><strong>目的IP地址（Destination Address）：</strong> 32位，接收方的IP地址。</li><li><strong>选项（Options）：</strong> 可选字段，长度可变，主要用于调试、测试或特殊控制功能。</li></ul><h4 id="数据（Data-Payload）"><a href="#数据（Data-Payload）" class="headerlink" title="数据（Data&#x2F;Payload）"></a>数据（Data&#x2F;Payload）</h4><p>   IPv4数据报的负载部分，携带上层协议（如TCP、UDP）的数据。根据总长度和首部长度的不同，数据部分的大小可变，最大可以达到65515字节（65535字节的总长度减去最小的20字节首部长度）。</p><p>IPv4的整个数据报结构如下所示：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|Version|  IHL  |Type of Service|          Total Length           |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|         Identification        |Flags|     Fragment Offset      |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|  Time to Live |    Protocol    |       Header Checksum          |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                         Source Address                         |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                      Destination Address                       |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                    Options (if any)                            |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                             Data                               |<br>|                                                               |<br>|                                                               |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><h3 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h3><p>不同链路层协议可能不能承载相同大小的网络层分组，一个链路层帧可以承载的最大数据量为<strong>最大传输单元</strong>。为了解决该问题，需要将IP数据报分为更小的数据报（切成<strong>片</strong>），用链路层帧来封装并发送。至于片的组装，不会放在路由器中，而是放在端系统中处理，以提高传输效率。数据报中的标识、标志、片偏移字段就是用来重组的。</p><h3 id="编址"><a href="#编址" class="headerlink" title="编址"></a>编址</h3><p>IP地址采用的是<strong>点分十进制记法</strong>，IP地址长度为32bits共4个字节，将每个字节用十进制来写，每个字节用.隔开，就可以得到IP地址。全球的每台主机和路由器的每个端口都有一个独一无二的IP地址，一个接口的IP地址一部分需要通过子网来确定。在一个子网中，多个接口的IP地址有共同的前缀。</p><p>Internet的地址分配策略为**无类别域间路由选择(CIDR)**，在使用子网寻址时，将地址变为<code>a.b.c.d/x</code>的形式，x代表了地址第一部分的bit数，前x位位该地址的前缀。一个组织会被分配一块连续的地址（具有相同的前缀）。网络中外部的路由器，只会考虑前缀，从而减少转发表的长度。剩余的bit用于区分内部设备。这种方式使得子网划分和分配十分灵活（x不需要为8的倍数）。</p><p>特例：目的地址为<code>255.255.255.255</code>的数据报回交付给同一个网络的所有主机，可能会转发给邻近的子网。</p><h3 id="获取地址"><a href="#获取地址" class="headerlink" title="获取地址"></a>获取地址</h3><p>为了获取一块IP地址用于子网，会先向ISP申请地址，ISP可以将已有的分配地址分配给需要者。如果ISP想要更多的地址，需要向ICANN组织申请。</p><p>一个组织在获取了一个一块地址后，需要分配给组织内的主机。显然手动分配过于麻烦，一般采取的是<strong>动态主机配置协议(DHCP)<strong>，也叫</strong>即插即用协议(plug-and-play protocol)&#x2F;零配置(zeroconf)协议</strong>，网络管理员可以设定某个主机在每次连入网络都被分配相同的地址，或者是不同的临时地址。</p><h4 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h4><p>对于一台新到达的主机，DHCP协议分为以下几步：</p><ul><li>主机发送**DHCP发现报文(DHCP discover message)**。使用广播地址255.255.255.255向所有主机的67端口发送该报文。</li><li>DHCP服务器收到一个DHCP发现报文，用**DHCP提供报文(DHCP offer message)**作出响应，使用广播地址。因为一个客户有可能可以在多个DHCP服务器中选择。</li><li>新的客户选择一个服务器，对其发送**DHCP请求报文(DHCP request message)**。</li><li>服务器用<strong>DHCP ACK message</strong>来对请求报文响应</li></ul><h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>**网络地址转换(NAT)**的工作原理是：</p><ul><li>所有的主机与 NAT 路由器连接，所有的主机对于外部世界看作是单个设备和一个 IP 地址，通过这一个 IP 地址不同的端口来区分内部的主机。</li><li>NAT 使用 NAT 转换表（NAT Translation Table） 将这个公开的 IP 地址加端口和所有内网 IP 地址加端口之间有一对一映射关系。也就是 NAT 转换表的一个记录，将公网 IP 和一个端口映射一个内网的进程。</li><li>外部客户端请求 NAT 内的主机，是通过请求 NAT 路由器的 IP 地址和指定端口，NAT 路由器接收到请求后，通过修改报文的目标地址为局域网地址，修改目标端口为进程的端口，将这个报文转发给内网的主机的一个进程。</li><li>NAT 内的主机访问外部的主机，请求经过 NAT 路由器的时候，NAT 路由器修改报文的源地址为 NAT 路由器的地址，修改源端口为 NAT 路由器的一个端口。</li><li>所有内网中的主机不直接与外部的通信，所有的通信都是 NAT 路由器与外部进行的。NAT 通过修改报文的内容从而达到与内网的通信。</li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv6（Internet Protocol Version 6）的数据格式相比IPv4进行了简化和优化，以提高路由效率和支持更大的地址空间。IPv6数据报由<strong>基本首部</strong>和<strong>有效载荷（数据部分）</strong>组成。以下是IPv6数据报的结构及其关键字段：</p><h4 id="IPv6首部（Header）"><a href="#IPv6首部（Header）" class="headerlink" title="IPv6首部（Header）"></a>IPv6首部（Header）</h4><p>   IPv6首部固定长度为<strong>40字节</strong>，相比IPv4的可变长度，IPv6的首部更简洁高效。IPv6首部各字段的含义如下：</p><ul><li><strong>版本（Version, 4位）：</strong> 表示IP协议的版本号，IPv6的值为6。</li><li><strong>流量类别（Traffic Class, 8位）：</strong> 类似于IPv4中的服务类型字段，用于定义数据包的优先级和服务质量（QoS）。</li><li><strong>流标签（Flow Label, 20位）：</strong> 用于标识同一流中的数据包，方便路由器识别和处理具有相同流标签的包，提高流量管理的效率。</li><li><strong>有效载荷长度（Payload Length, 16位）：</strong> 指定除首部外的数据部分的长度，最大可支持65535字节的有效载荷。若长度超过65535字节，则使用扩展首部。</li><li><strong>下一个首部（Next Header, 8位）：</strong> 指定下一个首部的类型，通常指上层协议（如TCP、UDP），也可以指IPv6的扩展首部。</li><li><strong>跳限制（Hop Limit, 8位）：</strong> 类似于IPv4的TTL（Time to Live），每经过一个路由器，该值减1，当值为0时，数据包被丢弃。</li><li><strong>源地址（Source Address, 128位）：</strong> 发送方的IPv6地址。</li><li><strong>目的地址（Destination Address, 128位）：</strong> 接收方的IPv6地址。</li></ul><h4 id="扩展首部（Extension-Headers）"><a href="#扩展首部（Extension-Headers）" class="headerlink" title="扩展首部（Extension Headers）"></a>扩展首部（Extension Headers）</h4><p>   与IPv4不同，IPv6引入了<strong>扩展首部</strong>机制，用于处理不同的功能需求，如路由、分片、认证等。扩展首部是可选的，并且在基本首部和有效载荷之间插入。常见的扩展首部有：</p><ul><li><strong>路由首部（Routing Header）：</strong> 指定数据包经过的路由路径。</li><li><strong>分片首部（Fragment Header）：</strong> IPv6通常不在中间路由器进行分片，但在源节点需要对大数据包进行分片时，使用此扩展首部。</li><li><strong>认证首部（Authentication Header）：</strong> 用于数据包的认证和完整性检查，确保数据的安全性。</li><li><strong>ESP首部（Encapsulating Security Payload Header）：</strong> 用于加密数据包的有效载荷，确保数据的机密性。</li></ul><h4 id="数据部分（Payload）"><a href="#数据部分（Payload）" class="headerlink" title="数据部分（Payload）"></a>数据部分（Payload）</h4><p>   数据部分是IPv6数据报的有效载荷，包含上层协议的数据（如TCP、UDP等）。有效载荷的长度由首部的<strong>有效载荷长度</strong>字段指定。对于超大数据包，可以通过扩展首部进行进一步处理。</p><h4 id="IPv6数据报结构："><a href="#IPv6数据报结构：" class="headerlink" title="IPv6数据报结构："></a>IPv6数据报结构：</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|Version| Traffic Class |              Flow Label                |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|      Payload Length           | Next Header |   Hop Limit      |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                                                               |<br>|                         Source Address                        |<br>|                                                               |<br>|                                                               |<br>|                                                               |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                                                               |<br>|                      Destination Address                      |<br>|                                                               |<br>|                                                               |<br>|                                                               |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                                                               |<br>|                      Extension Headers (if any)               |<br>|                                                               |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br>|                                                               |<br>|                           Payload                             |<br>|                                                               |<br><span class="hljs-addition">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></code></pre></td></tr></table></figure><h1 id="通用转发"><a href="#通用转发" class="headerlink" title="通用转发"></a>通用转发</h1><p>我们发现前文的基于目的地的转发，都是使用<strong>匹配+动作</strong>的模式，匹配指的是寻找目的的ip地址，动作指的是将分组发送到特定的输出端口。在通用转发中，两个词的更加通用，在这里的匹配指的是对多个首部字段的匹配，动作包括了转发、重写首部值（如NAT），阻挡&#x2F;丢弃（防火墙），负载均衡分组等。每台分组交换机都有一张匹配加动作表，由远程控制器计算。</p><hr><blockquote><p><em><strong>PART2：控制平面</strong></em></p></blockquote><h1 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h1><p>对于网络的路由，我们可以抽象成一个<strong>图</strong>，每个路由器代表一个节点，边代表了链路，边的值代表了其开销。我们的目的是，找出从源到目的地的最短开销路径。一般来说，路由选择算法可以分为：</p><ul><li><strong>集中式(centralized)<strong>：用完整的、全局的网络信息计算最短开销路径。具有全局状态信息的算法常叫做</strong>链路状态(LS)算法</strong>。</li><li><strong>分散式(decentralized)<strong>：没有节点有完整的全局信息，通过迭代和分布式方式计算最低开销路径。一个例子是</strong>距离向量(DV)算法</strong>。</li></ul><h2 id="LS路由选择算法"><a href="#LS路由选择算法" class="headerlink" title="LS路由选择算法"></a>LS路由选择算法</h2><p>为了每个节点都可以得知全局的信息，所有节点都会向网络中的所有节点广播链路状态的分组，使用<strong>链路广播算法</strong>。对于一个节点，在得到信息后，会使用路由选择算法（这里用Dijkstra算法）来计算从该节点到所有节点的最小开销路径</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-type">#</span> <span class="hljs-built_in">N</span> 为节点全集<br><span class="hljs-type">#</span> <span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;</span> 代表了已知最小开销路径的目标节点的集合<br><span class="hljs-type">#</span> <span class="hljs-variable">v</span> 代表一个节点<br><span class="hljs-type">#</span> <span class="hljs-variable">u</span> 为源节点<br><span class="hljs-type">#</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span> 为从源节点到目标节点的最小开销（本次迭代）<br><br><span class="hljs-type">#</span> <span class="hljs-variable">Init</span><span class="hljs-operator">:</span><br><span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-variable">u</span><span class="hljs-punctuation">&#125;</span> <br><span class="hljs-variable">for</span> <span class="hljs-variable">all</span> <span class="hljs-variable">nodes</span> <span class="hljs-variable">v</span><br><span class="hljs-variable">if</span> <span class="hljs-variable">v</span> <span class="hljs-variable">is</span> <span class="hljs-variable">a</span> <span class="hljs-variable">neighbor</span> <span class="hljs-variable">of</span> <span class="hljs-variable">u</span><br><span class="hljs-variable">then</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">c</span><span class="hljs-punctuation">(</span><span class="hljs-variable">u</span><span class="hljs-operator">,</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">else</span> <br><span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">INF</span><br><br><span class="hljs-type">#</span> <span class="hljs-variable">Interate</span><span class="hljs-operator">:</span><br><br><span class="hljs-variable">Loop</span>：<br><span class="hljs-variable">find</span> <span class="hljs-variable">w</span> <span class="hljs-variable">not</span> <span class="hljs-variable">in</span> <span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;</span> <span class="hljs-variable">and</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">w</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">is</span> <span class="hljs-variable">minimum</span><br><span class="hljs-variable">add</span> <span class="hljs-variable">w</span> <span class="hljs-variable">to</span> <span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;</span><br><span class="hljs-variable">update</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span> <span class="hljs-variable">for</span> <span class="hljs-variable">each</span> <span class="hljs-variable">neighbor</span> <span class="hljs-variable">v</span> <span class="hljs-variable">of</span> <span class="hljs-variable">w</span> <span class="hljs-variable">and</span> <span class="hljs-variable">not</span> <span class="hljs-variable">in</span> <span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;:</span><br><span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-variable">min</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-built_in">D</span><span class="hljs-punctuation">(</span><span class="hljs-variable">w</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> <span class="hljs-variable">c</span><span class="hljs-punctuation">(</span><span class="hljs-variable">w</span><span class="hljs-operator">,</span><span class="hljs-variable">v</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><span class="hljs-variable">until</span> <span class="hljs-built_in">N</span><span class="hljs-operator">&#x27;</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">N</span><br></code></pre></td></tr></table></figure><p>值得注意的是，当一种算法使用&#x3D;&#x3D;拥塞或者时延&#x3D;&#x3D;来确定链路的开销，有可能会导致路由选择的振荡，（当算法选择了一个路径，导致路径流量变化，可能会影响下一次的判断）。一种解决办法是，让每台路由器发送通告的时间随机化。</p><h2 id="DV路由选择算法"><a href="#DV路由选择算法" class="headerlink" title="DV路由选择算法"></a>DV路由选择算法</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Initialization:<br><span class="hljs-keyword">for</span> <span class="hljs-attribute">all</span> destination y in N:<br><span class="hljs-built_in">Dx</span>(<span class="hljs-attribute">y</span>) = <span class="hljs-built_in">c</span>(x,y) <span class="hljs-comment">/* if y is not a neighbor then c(x,y) = ∞ */</span><br><span class="hljs-keyword">for</span> each neighbor w<br><span class="hljs-built_in">Dw</span>(<span class="hljs-attribute">y</span>) = ? for all destinations y in N<br><span class="hljs-keyword">for</span> each neighbor w<br>send distance vector Dx = <span class="hljs-selector-attr">[Dx(y): y in N]</span> to w<br><br>loop<br>wait (until I see <span class="hljs-selector-tag">a</span> link cost change to some neighbor w or until I receive <span class="hljs-selector-tag">a</span> distance vector <span class="hljs-selector-tag">form</span> some neighbor w)<br><span class="hljs-keyword">for</span> each <span class="hljs-attribute">y</span> in N:<br><span class="hljs-built_in">Dx</span>(<span class="hljs-attribute">y</span>) = minv&#123;<span class="hljs-built_in">c</span>(x,v) + <span class="hljs-built_in">Dv</span>(y)&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">Dx</span>(<span class="hljs-attribute">y</span>) changed for any destination y<br>send distance vector Dx = <span class="hljs-selector-attr">[Dx(y): y in N]</span> to <span class="hljs-attribute">all</span> neighbors<br>forever<br><br></code></pre></td></tr></table></figure><p>在链路开销改变时，可能导致<strong>路由选择环路</strong>，可以看下下面这个简单的例子：</p><p><code>A-1-B-1-C</code></p><p>在这条路径中，节点C需要通过B来得到其到A的最小开销。当A对B突然不可达时，B需要重新计算距离向量。但此时C告诉B：自己可以以2的代价到达A，于是对于B，到A的最小开销更新为3（通过C去）。这时候C更新，到A的代价为4。导致B更新，到A的代价为5，以此类推，像进入了黑洞。这个问题被称为<strong>无穷计数问题</strong>。</p><p><strong>毒性逆转</strong>可以解决这个问题。具体地，上面的例子中，C会“欺骗”B，告诉B：自己无法到达A。（关于A，C的情报通过B来获得，没有理由C还能反过来告诉B有关A的信息）通过这种方法&#x3D;&#x3D;毒化&#x3D;&#x3D;逆向路径。然而涉及到3个包括更多的节点的环路无法通过这个技术检测到。</p><h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>当路由器的规模变得巨大，需要将路由器组织进<strong>自治系统</strong>，便于：</p><ul><li>减小算法运行的规模</li><li>管理自治</li></ul><p>在同一个AS下的路由器都使用相同的路由选择算法，这个算法叫做<strong>自治系统内部路由选择协议</strong>，**开放最短路径优先(OSPF)**就是其中一种。OSPF使用的是LS算法，各条链路的开销由网络管理员配置。</p><h1 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h1><p>当分组跨越多个AS进行路由时，需要<strong>自治系统间路由协议</strong>。在Internet中，所有的AS都运行相同的AS间路由选择协议，即**边界网关协议(BGP)**。对于BGP，路由的地址是CIDR化的前缀。</p><h2 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h2><p>BGP使得每个路由器可以获得前缀的&#x3D;&#x3D;可达性信息&#x3D;&#x3D;。</p><p>在一个AS中，分为<strong>网关路由器</strong>和<strong>内部路由器</strong>。在BGP中，每对路由器使用179端口的TCP连接交换路由信息，其中发送的BGP报文称为<strong>BGP连接</strong>。跨AS的BGP连接为eBGP连接，AS内的BGP连接为iBGP连接。</p><p>假设网络由3个AS组成：<br><code>AS1-AS2-AS3</code>，其中节点x在AS3中，现在需要所有路由器通告关于x的可达性信息，AS3的网关路由器会向连接的AS2的网关路由器发送<code>AS3 x</code>，该AS2的网关路由器会将该报文转发给同AS下所有路由器，AS2向AS1发送<code>AS2 AS3 x</code>的报文（和AS3到2类似），最终，AS2和AS1的所有路由器都知道x存在及到x的路径</p><h2 id="确定最佳路由"><a href="#确定最佳路由" class="headerlink" title="确定最佳路由"></a>确定最佳路由</h2><p>路由器通过BGP连接通告前缀时，其前缀包括一些<strong>BGP属性</strong>，这里我们需要用到<strong>AS-PATH</strong>（已经通过的AS的列表），<strong>NEXT-HOP</strong>（AS-PATH起始的路由器的IP地址）。</p><h3 id="hot-potato-routing"><a href="#hot-potato-routing" class="headerlink" title="hot-potato-routing"></a>hot-potato-routing</h3><p>最核心的思想是，分组就像热土豆一样烫手，每个AS都想尽快将其交给下一个AS。</p><p>对于网络中的一个路由器，假设其有到达前缀x的多个BGP路由可以选择。对于每个BGP路由，其会找到&#x3D;&#x3D;到达NEXT-HOP的最短路径&#x3D;&#x3D;。其会选择&#x3D;&#x3D;最短路径&#x3D;&#x3D;开销最小的BGP路由。</p><h3 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h3><p>在实际中的算法，结合了热土豆路由选择，会顺序调用以下的规则，直到选出路由：</p><ul><li><strong>选择具有最高本地偏好的路由</strong>：本地偏好的值可以由网络管理员设定。通过这条规则，可以避免一个网络承担其不愿承担的负载，或者用于将流量导到专门的线路上。</li><li><strong>选择有最短AS-PATH的路由</strong>：（本地偏好值都相同）距离测度使用的是AS的跳数而非路由器的。</li><li><strong>热土豆路由选择</strong>：（本地偏好值都相同且AS-PATH长度相同）</li><li><strong>使用BGP标识符</strong></li></ul><h2 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h2><p>对于CDN，使用BGP，可以让客户请求距离最近的服务器。</p><p>IP任播常用于将DNS请求导向最近的根DNS服务器</p><h1 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h1><p>即为Internet控制报文协议，用于主机和路由器间沟通网络层的信息。ICMP承载在IP分组中，上层协议编码为1。ICMP可以用于拥塞控制，追踪路由路径（如Traceroute程序的原理）</p><h1 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h1><p>简单网络管理协议，常使用请求响应模式……（todo）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-check4</title>
    <link href="/2024/09/25/CS144-check4/"/>
    <url>/2024/09/25/CS144-check4/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>这个实验相当于测试前几个实验的搭建的TCP栈的正确性，我的代码实现没有问题，所以在实验4不再需要改主要的代码。只需要在webget中修改<code>TCPSocket</code>为<code>CS144TCPSocket</code>并加上对应的头文件，运行配置的脚本，就可以使用我们自己实现的TCP协议栈在网络中通信了！</p><p>值得注意的是，UTM的Emulated VLAN模式下好像并不能ping，要使用Shared Network才行。</p><p>由于时间问题，我只跑了一个小时的数据，以下为数据的分析以及分析的源码。</p><h2 id="data-analyzing"><a href="#data-analyzing" class="headerlink" title="data analyzing"></a>data analyzing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># Read the data from the file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    data = file.read()<br><br><span class="hljs-comment"># compute the overall delivery date</span><br>icmp_seq_numbers = re.findall(<span class="hljs-string">r&#x27;icmp_seq=(\d+)&#x27;</span>, data)<br>icmp_seq_numbers = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, icmp_seq_numbers))  <span class="hljs-comment"># Convert to integers</span><br><br>min_seq = <span class="hljs-built_in">min</span>(icmp_seq_numbers)<br>max_seq = <span class="hljs-built_in">max</span>(icmp_seq_numbers)<br><br>expected_seq_numbers = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">range</span>(min_seq, max_seq + <span class="hljs-number">1</span>))<br><br>missing_seq_numbers = expected_seq_numbers - <span class="hljs-built_in">set</span>(icmp_seq_numbers)<br>missing_numbers_len = <span class="hljs-built_in">len</span>(missing_seq_numbers)<br>overall_delivery_rate = <span class="hljs-number">1</span> - <span class="hljs-built_in">len</span>(missing_seq_numbers) / <span class="hljs-built_in">len</span>(expected_seq_numbers)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;overall delivery date: <span class="hljs-subst">&#123;overall_delivery_rate&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># find the longest consecutive string of successful pings</span><br>longest_streak = <span class="hljs-number">1</span><br>current_streak = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(icmp_seq_numbers)):<br>    <span class="hljs-keyword">if</span> icmp_seq_numbers[i] == icmp_seq_numbers[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>        current_streak += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        longest_streak = <span class="hljs-built_in">max</span>(longest_streak, current_streak)<br>        current_streak = <span class="hljs-number">1</span>  <span class="hljs-comment"># Reset for the next potential sequence</span><br><br>longest_streak = <span class="hljs-built_in">max</span>(longest_streak, current_streak)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Length of the longest consecutive sequence: <span class="hljs-subst">&#123;longest_streak&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># Find the length of the longest consecutive missing sequence</span><br>missing_seq_numbers = <span class="hljs-built_in">sorted</span>(expected_seq_numbers - <span class="hljs-built_in">set</span>(icmp_seq_numbers))<br>longest_missing_streak = <span class="hljs-number">0</span><br>current_streak = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(missing_seq_numbers)):<br>    <span class="hljs-keyword">if</span> missing_seq_numbers[i] == missing_seq_numbers[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>:<br>        current_streak += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        longest_missing_streak = <span class="hljs-built_in">max</span>(longest_missing_streak, current_streak + <span class="hljs-number">1</span>)  <span class="hljs-comment"># +1 to count the first missing number</span><br>        current_streak = <span class="hljs-number">0</span><br><br>longest_missing_streak = <span class="hljs-built_in">max</span>(longest_missing_streak, current_streak + <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Length of the longest consecutive missing sequence: <span class="hljs-subst">&#123;longest_missing_streak&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># Compute the independent or correlated of &quot;packet losses&quot;</span><br>received_replies = <span class="hljs-built_in">set</span>(icmp_seq_numbers)<br><br>successful_n = <span class="hljs-number">0</span><br>successful_n_plus_1 = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(received_replies), <span class="hljs-built_in">max</span>(received_replies)):<br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">in</span> received_replies:<br>        successful_n += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n + <span class="hljs-number">1</span> <span class="hljs-keyword">in</span> received_replies:<br>            successful_n_plus_1 += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> successful_n &gt; <span class="hljs-number">0</span>:<br>    probability = successful_n_plus_1 / successful_n<br><span class="hljs-keyword">else</span>:<br>    probability = <span class="hljs-number">0.0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Probability that echo request seqno #(N+1) was replied to given seqno #N was replied to: <span class="hljs-subst">&#123;probability:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)<br><br>unsuccessful_n = <span class="hljs-number">0</span><br>successful_n_plus_1 = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">min</span>(received_replies), <span class="hljs-built_in">max</span>(received_replies)):<br>    <span class="hljs-keyword">if</span> n <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> received_replies:<br>        unsuccessful_n += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> (n + <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> received_replies:<br>            successful_n_plus_1 += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> unsuccessful_n &gt; <span class="hljs-number">0</span>:<br>    probability = successful_n_plus_1 / unsuccessful_n<br><span class="hljs-keyword">else</span>:<br>    probability = <span class="hljs-number">0.0</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Probability that echo request seqno #(N+1) was replied to given seqno #N did not receive a reply: <span class="hljs-subst">&#123;probability:<span class="hljs-number">.2</span>f&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># RTT</span><br>rtt_values = re.findall(<span class="hljs-string">r&#x27;time=(\d+\.?\d*) ms&#x27;</span>, data)<br>rtt_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, rtt_values))<br>min_rtt = <span class="hljs-built_in">min</span>(rtt_values)<br>max_rtt = <span class="hljs-built_in">max</span>(rtt_values)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Minimum RTT seen over the entire interval: <span class="hljs-subst">&#123;min_rtt:<span class="hljs-number">.2</span>f&#125;</span> ms&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Maximum RTT seen over the entire interval: <span class="hljs-subst">&#123;max_rtt:<span class="hljs-number">.2</span>f&#125;</span> ms&quot;</span>)<br></code></pre></td></tr></table></figure><p>测试的结果：</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs leaf">overall delivery date: 0.958145555662096<br>Length of the longest consecutive sequence: 311<br>Length of the longest consecutive missing sequence: 300<br>Probability that echo request seqno <span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">N</span><span class="hljs-operator">+</span>1)</span> was replied to given seqno <span class="hljs-punctuation">#</span><span class="hljs-keyword">N</span> was replied to: 0.98<br>Probability that echo request seqno <span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-variable">N</span><span class="hljs-operator">+</span>1)</span> was replied to given seqno <span class="hljs-punctuation">#</span><span class="hljs-keyword">N</span> did not receive a reply: 0.41<br>Minimum RTT seen over the entire interval: 457.00 ms<br>Maximum RTT seen over the entire interval: 1164.00 ms<br></code></pre></td></tr></table></figure><h2 id="graph-analyzing"><a href="#graph-analyzing" class="headerlink" title="graph analyzing"></a>graph analyzing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># Read the data from the file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    data = file.read()<br><br><span class="hljs-comment"># Extract RTT values and timestamps using regular expressions</span><br>timestamps = re.findall(<span class="hljs-string">r&#x27;\[(\d+\.\d+)\] 64 bytes&#x27;</span>, data)<br>rtt_values = re.findall(<span class="hljs-string">r&#x27;time=(\d+\.?\d*) ms&#x27;</span>, data)<br><br><span class="hljs-comment"># Convert RTT values to float</span><br>rtt_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, rtt_values))<br><br><span class="hljs-comment"># Convert timestamps to datetime format</span><br>timestamps = [pd.to_datetime(<span class="hljs-built_in">float</span>(ts), unit=<span class="hljs-string">&#x27;s&#x27;</span>, origin=<span class="hljs-string">&#x27;unix&#x27;</span>) <span class="hljs-keyword">for</span> ts <span class="hljs-keyword">in</span> timestamps]<br><br><span class="hljs-comment"># Create a DataFrame for easier plotting</span><br>df = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Time&#x27;</span>: timestamps, <span class="hljs-string">&#x27;RTT&#x27;</span>: rtt_values&#125;)<br><br><span class="hljs-comment"># Plotting</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>plt.plot(df[<span class="hljs-string">&#x27;Time&#x27;</span>], df[<span class="hljs-string">&#x27;RTT&#x27;</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, linestyle=<span class="hljs-string">&#x27;-&#x27;</span>, color=<span class="hljs-string">&#x27;b&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;RTT as a Function of Time&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Time of Day&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;RTT (ms)&#x27;</span>)<br>plt.xticks(rotation=<span class="hljs-number">45</span>)<br>plt.grid()<br><br><span class="hljs-comment"># Show the plot</span><br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="/images/Figure_1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># Read the data from the file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    data = file.read()<br><br><span class="hljs-comment"># Extract RTT values using regular expressions</span><br>rtt_values = re.findall(<span class="hljs-string">r&#x27;time=(\d+\.?\d*) ms&#x27;</span>, data)<br>rtt_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, rtt_values))  <span class="hljs-comment"># Convert to float</span><br><br><span class="hljs-comment"># Check if there are RTT values</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> rtt_values:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;No RTT values found.&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># Plot Histogram</span><br>    plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>    plt.hist(rtt_values, bins=<span class="hljs-number">30</span>, edgecolor=<span class="hljs-string">&#x27;black&#x27;</span>, alpha=<span class="hljs-number">0.7</span>)<br>    plt.title(<span class="hljs-string">&#x27;Histogram of RTTs&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;RTT (ms)&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Frequency&#x27;</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.show()<br><br>    <span class="hljs-comment"># Plot Cumulative Distribution Function (CDF)</span><br>    plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>    sorted_rtt = np.sort(rtt_values)<br>    cdf = np.arange(<span class="hljs-built_in">len</span>(sorted_rtt)) / <span class="hljs-built_in">float</span>(<span class="hljs-built_in">len</span>(sorted_rtt))<br>    plt.plot(sorted_rtt, cdf, marker=<span class="hljs-string">&#x27;.&#x27;</span>, linestyle=<span class="hljs-string">&#x27;none&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Cumulative Distribution Function (CDF) of RTTs&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;RTT (ms)&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;CDF&#x27;</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="/images/Figure_2.png"><br><img src="/images/Figure_2.1.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># Read the data from the file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;data.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    data = file.read()<br><br><span class="hljs-comment"># Extract RTT values using regular expressions</span><br>rtt_values = re.findall(<span class="hljs-string">r&#x27;time=(\d+\.?\d*) ms&#x27;</span>, data)<br>rtt_values = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, rtt_values))  <span class="hljs-comment"># Convert to float</span><br><br><span class="hljs-comment"># Create pairs of consecutive RTT values (N and N+1)</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(rtt_values) &lt; <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Not enough RTT values for correlation analysis.&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    rtt_N = rtt_values[:-<span class="hljs-number">1</span>]   <span class="hljs-comment"># RTT of ping #N</span><br>    rtt_N_plus_1 = rtt_values[<span class="hljs-number">1</span>:]  <span class="hljs-comment"># RTT of ping #N+1</span><br><br>    <span class="hljs-comment"># Plot RTT of ping #N vs RTT of ping #N+1</span><br>    plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br>    plt.scatter(rtt_N, rtt_N_plus_1, alpha=<span class="hljs-number">0.6</span>, edgecolors=<span class="hljs-string">&#x27;black&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;Correlation between RTT of Ping #N and RTT of Ping #N+1&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;RTT of Ping #N (ms)&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;RTT of Ping #N+1 (ms)&#x27;</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="/images/Figure_3.png"></p><p>由图表可以看出，两者几乎是独立的概率，前者并不会影响后者。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><em><strong>阶段性胜利！！！</strong></em>，让我们接着实现IP栈吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-check3</title>
    <link href="/2024/09/24/CS144-check3/"/>
    <url>/2024/09/24/CS144-check3/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>这个lab需要我们实现TCP协议中的发送方。</p><blockquote><p>接收方只需要接收就行了，但发送方要考虑的就多了…</p></blockquote><p>大概来说，需要实现下面的功能：</p><ul><li>根据接收方提供的信息，去发送尽可能大的报文填满接收方的window</li><li>记录<strong>发送了但还没被接收方确认</strong>的报文</li><li>超时重传</li></ul><h2 id="implement"><a href="#implement" class="headerlink" title="implement"></a>implement</h2><p>以下为我的实现（可能并非最终版），本质是一坨面向测试的屎山，以后报错严重有可能要重构。</p><h3 id="members"><a href="#members" class="headerlink" title="members"></a>members</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPSender</span><br>&#123;<br>...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Variables initialized in constructor</span><br>  ByteStream input_;<br>  Wrap32 isn_;<br>  <span class="hljs-type">uint64_t</span> initial_RTO_ms_;<br>  <span class="hljs-type">uint64_t</span> RTO_ &#123;initial_RTO_ms_&#125;;<br>  <span class="hljs-type">uint64_t</span> next_seqno_ &#123;&#125;;<br>  <span class="hljs-type">bool</span> is_retry_ &#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">uint64_t</span> retrans_times_ &#123;&#125;;<br>  <span class="hljs-type">bool</span> has_send_SYN &#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">bool</span> has_send_FIN &#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">uint64_t</span> window_size_ &#123;<span class="hljs-number">1</span>&#125;;<br>  std::list&lt;TCPSenderMessage&gt; segments &#123;&#125;;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">retransmission_timer</span> &#123;<br>    <span class="hljs-type">bool</span> has_on &#123;<span class="hljs-literal">false</span>&#125;;<br>    <span class="hljs-type">uint64_t</span> t &#123;&#125;;<br>    <span class="hljs-type">uint64_t</span> expire_time;<br>  &#125; alarm;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>屎山中的屎山！存在以下问题：</p><ul><li>too much copy-paste：像启动时钟，几乎相同的代码在同一个函数里面出现了4次，如果需要修改会带来巨大的问题。</li><li>糟糕的条件判断：因为暂时还没想到一个统一的应对绝大部分情况的方法，所以写得极其丑陋</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::push</span><span class="hljs-params">( <span class="hljs-type">const</span> TransmitFunction&amp; transmit )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// if window_size_ &lt; sequence_numbers_in_flight(),</span><br>  <span class="hljs-comment">// the following sz will be a huge number(due to uint) and cost terrible situation...</span><br>  <span class="hljs-keyword">if</span>(window_size_ &lt; <span class="hljs-built_in">sequence_numbers_in_flight</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// sz : the numbers of bytes sender should try to fill in </span><br>  <span class="hljs-type">uint64_t</span> sz = window_size_ - <span class="hljs-built_in">sequence_numbers_in_flight</span>();<br>  <span class="hljs-type">uint64_t</span> length;<br><br>  <span class="hljs-comment">// special case</span><br>  <span class="hljs-keyword">if</span>(sz == <span class="hljs-number">0</span> &amp;&amp; window_size_ == <span class="hljs-number">0</span>)&#123;<br>    sz = <span class="hljs-number">1</span>;<br>  &#125;<br>    <br>  <span class="hljs-comment">// special case: SYN + FIN</span><br>  <span class="hljs-keyword">if</span>(sz &gt; <span class="hljs-number">0</span> &amp;&amp; next_seqno_ == <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">is_finished</span>() &amp;&amp; !has_send_SYN &amp;&amp; !has_send_FIN)&#123;<br>    TCPSenderMessage t;<br>    t.FIN = <span class="hljs-literal">true</span>;<br>    t.SYN = <span class="hljs-literal">true</span>;<br>    has_send_SYN = <span class="hljs-literal">true</span>;<br>    has_send_FIN = <span class="hljs-literal">true</span>;<br>    t.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">has_error</span>())<br>      t.RST = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">transmit</span>(t);<br>    segments.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">if</span>(alarm.has_on == <span class="hljs-literal">false</span>)&#123;<br>      alarm.has_on = <span class="hljs-literal">true</span>;<br>      alarm.t = <span class="hljs-number">0</span>;<br>      alarm.expire_time = RTO_;<br>    &#125;<br>    sz -= <span class="hljs-number">2</span>;<br>    next_seqno_ += <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// special case: only FIN</span><br>  <span class="hljs-keyword">if</span>(sz &gt; <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_buffered</span>() == <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">is_finished</span>() &amp;&amp; !has_send_FIN)&#123;<br>    TCPSenderMessage t;<br>    t.FIN = <span class="hljs-literal">true</span>;<br>    has_send_FIN = <span class="hljs-literal">true</span>;<br>    t.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">has_error</span>())<br>      t.RST = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">transmit</span>(t);<br>    segments.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">if</span>(alarm.has_on == <span class="hljs-literal">false</span>)&#123;<br>      alarm.has_on = <span class="hljs-literal">true</span>;<br>      alarm.t = <span class="hljs-number">0</span>;<br>      alarm.expire_time = RTO_;<br>    &#125;<br>    sz -= <span class="hljs-number">1</span>;<br>    next_seqno_ += <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// normol case</span><br>  <span class="hljs-keyword">while</span>(sz &gt; <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_buffered</span>())&#123;<br>    TCPSenderMessage t;<br>    <span class="hljs-type">uint64_t</span> bufsz = input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_buffered</span>();<br>    <span class="hljs-type">uint64_t</span> maxsz = TCPConfig::MAX_PAYLOAD_SIZE;<br><br>    <br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_popped</span>() == <span class="hljs-number">0</span> &amp;&amp; next_seqno_ == <span class="hljs-number">0</span>)&#123;<br>      t.SYN = <span class="hljs-literal">true</span>;<br>      bufsz += <span class="hljs-number">1</span>;<br>      maxsz += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br><br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">is_closed</span>())&#123;<br>      t.FIN = <span class="hljs-literal">true</span>;<br>      bufsz += <span class="hljs-number">1</span>;<br>      maxsz += <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">if</span>((bufsz &gt; sz &amp;&amp; maxsz &gt; sz) || (maxsz &lt; sz &amp;&amp; maxsz &lt; bufsz))&#123;<br>        t.FIN = <span class="hljs-literal">false</span>;<br>        bufsz -= <span class="hljs-number">1</span>;<br>        maxsz -= <span class="hljs-number">1</span>;<br>      &#125;<br>    &#125;<br><br>    t.payload = input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">peek</span>();<br>    length = <span class="hljs-built_in">min</span>(&#123;sz, maxsz, bufsz&#125;) - t.SYN - t.FIN;<br>    t.payload = t.payload.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, length);<br>    t.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">has_error</span>())<br>      t.RST = <span class="hljs-literal">true</span>;<br><br>    input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">pop</span>(t.payload.<span class="hljs-built_in">size</span>());<br>    sz -= t.<span class="hljs-built_in">sequence_length</span>();<br><br>    <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">sequence_length</span>())&#123;<br>      <span class="hljs-built_in">transmit</span>(t);<br>      <span class="hljs-keyword">if</span>(t.SYN)<br>        has_send_SYN = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">if</span>(t.FIN)<br>        has_send_FIN = <span class="hljs-literal">true</span>;<br>      segments.<span class="hljs-built_in">push_back</span>(t);<br>      <span class="hljs-keyword">if</span>(window_size_ == <span class="hljs-number">0</span>)<br>        is_retry_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>      <br>    <br>    next_seqno_ += t.<span class="hljs-built_in">sequence_length</span>();<br><br>    <span class="hljs-keyword">if</span>(alarm.has_on == <span class="hljs-literal">false</span>)&#123;<br>      alarm.has_on = <span class="hljs-literal">true</span>;<br>      alarm.t = <span class="hljs-number">0</span>;<br>      alarm.expire_time = RTO_;<br>    &#125;<br><br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(sz &gt; <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_buffered</span>() == <span class="hljs-number">0</span> &amp;&amp; input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_popped</span>() == <span class="hljs-number">0</span> &amp;&amp; next_seqno_ == <span class="hljs-number">0</span> &amp;&amp; !has_send_SYN)&#123;<br>    <span class="hljs-comment">// send isn and syn with 0 payload</span><br>    TCPSenderMessage t;<br>    t.SYN = <span class="hljs-literal">true</span>;<br>    has_send_SYN = <span class="hljs-literal">true</span>;<br>    t.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>    <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">has_error</span>())<br>      t.RST = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">transmit</span>(t);<br>    segments.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">if</span>(alarm.has_on == <span class="hljs-literal">false</span>)&#123;<br>      alarm.has_on = <span class="hljs-literal">true</span>;<br>      alarm.t = <span class="hljs-number">0</span>;<br>      alarm.expire_time = RTO_;<br>    &#125;<br>    sz -= <span class="hljs-number">1</span>;<br>    next_seqno_ += <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>贴完代码，讲一下我认为如果需要再次实现时需要注意的边界&#x2F;特殊情况：</p><ul><li>注意SYN和FIN都占window的位置<ul><li>SYN相对好处理</li><li>FIN需要考虑，即便当前发送的报文以及到达stream的最后一个字，但加上FIN刚好无法放入window，这个报文不能加上FIN。如果sz是最小的，肯定不能放入FIN。如果payload的最大值是最小的，显然也不能加上FIN。</li></ul></li><li>window的size如果小于outstanding的seqno数，就不要再push了。</li><li>window的size等于0：<ul><li>需要push<strong>当作</strong>它的size是1（但不要改变真正的window_size），因为可能需要这个机制来唤醒接收方，如果接收方window_size从0变大。</li><li>但我们在这种情况发出去的报文，需要特别对待，下文在超时重传中会说。</li></ul></li></ul><h3 id="receive"><a href="#receive" class="headerlink" title="receive"></a>receive</h3><p>receive可以基本按照实验手册来写。基本的思路就是检查ackno，可能删除记录的未确认报文，修改window的size。当window的大小不为0时，需要修改is_retry，来使发送的报文的超时策略改变。（下文会提）。注意不能接受过大的ackno，过大的ackno可以看作干扰的信息，不符合协议。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::receive</span><span class="hljs-params">( <span class="hljs-type">const</span> TCPReceiverMessage&amp; msg )</span></span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-keyword">if</span>(msg.RST)<br>    input_.<span class="hljs-built_in">set_error</span>();<br>  <br>  <span class="hljs-keyword">if</span>(msg.ackno-&gt;<span class="hljs-built_in">unwrap</span>(isn_, input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_popped</span>()) &gt; next_seqno_)<br>    <span class="hljs-keyword">return</span>;<br>  <br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = segments.<span class="hljs-built_in">begin</span>(); it != segments.<span class="hljs-built_in">end</span>();)&#123;<br>    <span class="hljs-keyword">if</span>(msg.ackno-&gt;<span class="hljs-built_in">unwrap</span>(isn_, input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_popped</span>()) <br>    &gt;= (*it).seqno.<span class="hljs-built_in">unwrap</span>(isn_, input_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">bytes_popped</span>()) <br>    + (*it).<span class="hljs-built_in">sequence_length</span>())<br>    &#123;<br>      it = segments.<span class="hljs-built_in">erase</span>(it);<br>      RTO_ = initial_RTO_ms_;<br>      alarm.t = <span class="hljs-number">0</span>;<br>      alarm.expire_time = RTO_;<br>      retrans_times_ = <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      it++;<br>    &#125;<br>  &#125;<br>  <br>  window_size_ = msg.window_size;<br>  <span class="hljs-keyword">if</span>(window_size_)<br>    is_retry_ = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tick"><a href="#tick" class="headerlink" title="tick"></a>tick</h3><p>tick需要对alarm（计时器）的值加上传入的时间。我们在这里讨论超时重传的策略：</p><ul><li>在第一次发送报文时（push里面），启动计时器（如果计时器还没启动）</li><li>如果receive收到合法的ack，就删除seqno全部小于ackno的报文，即这些报文不会再超时重传（因为已经收到了）。</li><li>在tick里面，当计时器触发超时，需要重传并设置超时时间、重置计时器<ul><li>如果window的size为0就不用倍增超时时间，因为需要持续问询接收方的空间</li><li>如果不为0，需要倍增超时时间，因为超时代表了网络可能出现了拥塞</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPSender::tick</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> ms_since_last_tick, <span class="hljs-type">const</span> TransmitFunction&amp; transmit )</span></span><br><span class="hljs-function"></span>&#123;<br>  alarm.t += ms_since_last_tick;<br>  <span class="hljs-keyword">if</span>(segments.<span class="hljs-built_in">empty</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">if</span>(alarm.t &gt;= alarm.expire_time)&#123;<br>    retrans_times_ += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">transmit</span>(segments.<span class="hljs-built_in">front</span>());<br>    alarm.t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(!is_retry_)<br>      RTO_ *= <span class="hljs-number">2</span>;<br>    alarm.expire_time = RTO_;<br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="make-empty-message"><a href="#make-empty-message" class="headerlink" title="make_empty_message"></a>make_empty_message</h3><p>发送不需要超时重传的空信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TCPSenderMessage <span class="hljs-title">TCPSender::make_empty_message</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPSenderMessage t;<br>  t.seqno = Wrap32::<span class="hljs-built_in">wrap</span>(next_seqno_, isn_);<br>  <span class="hljs-keyword">if</span>(input_.<span class="hljs-built_in">has_error</span>())<br>    t.RST = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="others"><a href="#others" class="headerlink" title="others"></a>others</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::sequence_numbers_in_flight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> num = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = segments.<span class="hljs-built_in">begin</span>(); it != segments.<span class="hljs-built_in">end</span>(); it++)&#123;<br>    num += (*it).<span class="hljs-built_in">sequence_length</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> num;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">TCPSender::consecutive_retransmissions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> retrans_times_;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="友情提醒"><a href="#友情提醒" class="headerlink" title="友情提醒"></a>友情提醒</h2><ul><li>即使我们在前几个lab中通过了全部的测试，check4还是可能会出问题：真实的网络可能包含测试用例无法覆盖的情况。我还没开始做check4，但已经准备好check1-3的bug在check4一起爆出的情况了。</li><li>务必<strong>看熟</strong>实验手册后，有基本的想法再开始动手，至少保证不要理解错意思。在测试时，如果无法理解difftest的行为，说明你还是不理解或者理解错了。</li><li>面向测试编程？大概率会发生的事情，实验手册很多地方没讲太明白（可能一行就带过了理想行为）。测试常常会出现你没有考虑到的情况，或者是你以为你代码可以处理但实际上不能的情况。这个需要先看明白正确的程序行为。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-check2</title>
    <link href="/2024/09/19/CS144-check2/"/>
    <url>/2024/09/19/CS144-check2/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>这个lab需要我们实现TCP协议中的接收方，具体的，负责实现<strong>确认</strong>(acknowledgement)和<strong>流控制</strong>(flow control)。</p><h2 id="64bit-index-32bit-seqno"><a href="#64bit-index-32bit-seqno" class="headerlink" title="64bit index - 32bit seqno"></a>64bit index - 32bit seqno</h2><p>第一个部分，需要我们实现将上一个lab里面stream的index转换为TCP报文的序列号，指导书给出了序列号的特点：</p><ul><li>序列号只有32位，属于阿贝尔群</li><li>序列号并不一定从0开始，可以是随机数。第一个序列号被称为ISN(initial sequence number)。</li><li>对于每个stream，在其前面的SYN flag和FIN flag也是需要使用序列号的。</li></ul><p>为了方便，我们定义了64位<strong>绝对序列号</strong>，第一个序列号对应到绝对序列号为0，以此类推。而对于一个stream，其index就等于绝对序列号-1（SYN占据了0的位置）。</p><ul><li><code>wrap</code>实现了绝对序列号到序列号的转换</li><li><code>unwrap</code>实现了序列号到绝对序列号的转换</li></ul><p>因为序列号可能对应多个绝对序列号，所以需要找到离checkpoint最近的绝对序列号，每个比较都是采用绝对值，是为了防止边界情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Wrap32 <span class="hljs-title">Wrap32::wrap</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> n, Wrap32 zero_point )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> zero_point + <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint32_t</span>&gt;(n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Wrap32::unwrap</span><span class="hljs-params">( Wrap32 zero_point, <span class="hljs-type">uint64_t</span> checkpoint )</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> offset = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(raw_value_ - zero_point.raw_value_);<br>  <span class="hljs-type">uint64_t</span> t = offset + (checkpoint &amp; <span class="hljs-number">0xffffffff00000000</span>);<br>  <span class="hljs-type">uint64_t</span> dis1 = (t + (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>) &gt; checkpoint) ? (t + (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>) - checkpoint) : (checkpoint - t - (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>));<br>  <span class="hljs-type">uint64_t</span> dis2 = (t &gt; checkpoint) ? (t - checkpoint) : (checkpoint - t);<br>  <span class="hljs-type">uint64_t</span> dis3 = (t - (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>) &gt; checkpoint) ? (t - (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>) - checkpoint) : (checkpoint - t + (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>));<br>  <span class="hljs-type">uint64_t</span> ans;<br>  <span class="hljs-keyword">if</span>(dis1 &lt; dis2)&#123;<br>    <span class="hljs-keyword">if</span>(dis1 &lt; dis3)<br>      ans = t + (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>);<br>    <span class="hljs-keyword">else</span> <br>      ans = t - (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>(dis2 &lt; dis3)<br>      ans = t;<br>    <span class="hljs-keyword">else</span><br>      ans = t - (<span class="hljs-number">1UL</span> &lt;&lt; <span class="hljs-number">32</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TCP-receiver"><a href="#TCP-receiver" class="headerlink" title="TCP receiver"></a>TCP receiver</h2><p>这里需要我们正式开始实现接收方的动作。先把类中的成员丢在这里，下面解释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TCPReceiver</span><br>&#123;<br>...<br><span class="hljs-keyword">private</span>:<br>  Reassembler reassembler_;<br>  Wrap32 ISN &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-type">bool</span> ISN_recv &#123;<span class="hljs-literal">false</span>&#125;;<br>  <span class="hljs-type">uint64_t</span> ack_abseqno &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>指导书上只是讲了一些原理，但有一些东西没讲清楚。</p><ul><li>要注意我们需要发送的ackno是根据已接收并且已经按顺序排好的字节来设定的，需要使用first_unassemble_byte的位置来确定。</li><li>特别注意，每个stream都有一对SYN和FIN，都占序列号，不要忘记将他们加到ackno里面。</li></ul><p>其他的实现要素在指导书上都有，多读几遍，多看调试的信息就可以知道程序的行为了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TCPReceiver::receive</span><span class="hljs-params">( TCPSenderMessage message )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(message.RST)&#123;<br>    reassembler_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">set_error</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(message.SYN)&#123;<br>    ISN = message.seqno;<br>    ISN_recv = <span class="hljs-literal">true</span>;<br>    reassembler_.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, message.payload, message.FIN);<br>    ack_abseqno += message.<span class="hljs-built_in">sequence_length</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(!ISN_recv)<br>    <span class="hljs-keyword">return</span>;<br><br>  <br>  <span class="hljs-type">uint64_t</span> first_unindex = reassembler_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">bytes_pushed</span>();<br>  reassembler_.<span class="hljs-built_in">insert</span>(message.seqno.<span class="hljs-built_in">unwrap</span>(ISN, first_unindex)<span class="hljs-number">-1</span>, message.payload, message.FIN);<br>  ack_abseqno = reassembler_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">bytes_pushed</span>() + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(reassembler_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">is_closed</span>())<br>    ack_abseqno += <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function">TCPReceiverMessage <span class="hljs-title">TCPReceiver::send</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  TCPReceiverMessage t;<br>  <span class="hljs-keyword">if</span>(ISN_recv)&#123;<br>    t.ackno = Wrap32::<span class="hljs-built_in">wrap</span>(ack_abseqno, ISN);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span>(reassembler_.<span class="hljs-built_in">reader</span>().<span class="hljs-built_in">has_error</span>())<br>    t.RST = <span class="hljs-literal">true</span>;<br><br>  t.window_size = (reassembler_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>() &gt; UINT16_MAX) ? UINT16_MAX : reassembler_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-check1</title>
    <link href="/2024/09/12/CS144-check1/"/>
    <url>/2024/09/12/CS144-check1/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>需要我们构造一个神奇的类<code>Reassembler</code>，接受无序的substring，并在该类中恢复其顺序。capacity我认为为bytestream的buffer的capacity，available_capacity我认为为bytestream的available_capacity，下文称为<strong>有效区</strong></p><h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>刚完全理解时，觉得还挺简单的，具体的思路为，用一个链表将接收的substring收集起来，按照substring首个字节的index从小到大排序，每次收到一个first_index等于next_byte的substring，先将substring放进链表，接着update整个链表，具体地，将已经排好的连续的substring推入bytestream。想法很美丽，但现实是很苍白的。以下是我在面向测试编程时发现自己没考虑到的点：</p><ul><li><p>我们需要支持substring的first_index小于next_byte的情况，如果该substring有在有效区的部分，还需要写入而不能直接丢掉。</p></li><li><p>写入有效区的substring超出有效区的部分需要删除，但其保留的元素不能带有is_last_substring，否则会导致提前结束。</p></li><li><p>有效区内随时支持覆写(overlap)，只要该部分还没被推入buffer，就可以修改。</p></li><li><p>pending也是得支持overlap，对于覆写的部分不能重复统计。</p></li></ul><p>当我兴奋地发现代码通过前面的所有测试，准备安心下班时，最后一个测试居然报错了，说是读出来的数据和写入的不一样？？？？</p><p>由于之前的代码已经是屎山级别，难以辨认出问题，并且难以调试，因为数据量巨大，决定重写，以下为重写代码：</p><h2 id="success-implement"><a href="#success-implement" class="headerlink" title="success implement"></a>success implement</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// reassembler.hh</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reassembler</span><br>&#123;<br>...<br><span class="hljs-keyword">private</span>:<br>  ByteStream output_; <span class="hljs-comment">// the Reassembler writes to this ByteStream</span><br>  <span class="hljs-type">uint64_t</span> next_byte&#123;&#125;; <span class="hljs-comment">// store the next byte&#x27;s index aka. first unassembled index</span><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">substring</span><br>  &#123;<br>    <span class="hljs-keyword">public</span>:<br>    std::string data&#123;&#125;;<br>    <span class="hljs-type">uint64_t</span> first_byte&#123;&#125;;<br>    <span class="hljs-type">bool</span> is_last_substring&#123;&#125;;<br>  &#125;;<br>  std::list&lt;substring&gt; substrings&#123;&#125;;<br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unaccept_index</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// return the first unacceptable byte index </span><br>  <span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">unpopped_index</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// return the first unpopped byte index</span><br>  <span class="hljs-type">uint64_t</span> finish_index = <span class="hljs-number">0xfffffffff</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(substring &amp;st)</span></span>; <span class="hljs-comment">// scan the area and push all continous bytes in bytestream</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>以上为reassembler中的类以及成员：</p><ul><li><strong>next_byte</strong>：用于记录第一个不确定顺序的位置</li><li><strong>substrings</strong>：用于存放substring的列表，用list是因为我希望进入的substring可以按照first_byte的大小，从小到大顺序排放，并且支持快速的插入、删除，双向链表符合这些要求。</li><li><strong>unaccept_index</strong>：第一个无效的位置。</li><li><strong>finish_index</strong>：结束的位置，初始化为大数，主要用来避免空字符串放在首位且并非结束的情况。</li><li><strong>update</strong>：用于更新substrings列表，后文会介绍</li></ul><p>接下来是最复杂的部分，以及我的详细解决思路：</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>在<code>insert</code>中，将接收到的substring进行处理，我们接收到的substring无非就以下几种：</p><ul><li>完全不在有效区内：直接抛弃（注意有效区为0时需要特别判断）</li><li>存在一部分小于<code>next_byte</code>，这样的裁掉头部就行</li><li>存在一部分大于等于<code>unaccept_byte</code>，这样的裁掉尾部，注意裁掉尾部时，需要修改substring的is_last_substring的信息，因为裁掉尾步后，这个substring就不是最后一个了。</li></ul><p><em>注意是可能同时裁掉头部和尾部的！</em></p><p>明确类型，我们对应地进行处理就行，并将处理后的substring（如果不抛弃）放入我们的列表中（使用update传入substring），重活全部丢给update</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>注意在调用update之前，有一件事是确定的：此时列表里面不存在任何重叠（因为每次update都会处理重叠）</p><p>update的过程分成下面几步：</p><ul><li>寻找位置插入st，维持列表仍为按first_byte从小到大排序</li><li>检查前一个节点（只用找最近的一个，显然更前面的不会发生重叠）：<ul><li>如果st已经是列表的最前面，就不用找了</li><li>如果st的前一个substring的范围比st大，就丢掉st，以免切割前一个substring变成两部分，更加麻烦</li><li>如果st的前一个substring的范围和st不相交，什么都不用做</li><li>如果st和前一个substring有重叠部分，裁切前一个substring，避免调整first_byte可能导致的重新排序</li></ul></li><li>检查后一个节点的substring（需要一直往后找，直到发现不重叠的才结束）：<ul><li>如果st已经是列表的最后面，就不用找了</li><li>如果st和substring没有重叠，就直接结束（显然后面的也不会重叠了）</li><li>如果st完全包含在substring中（只有两者的first_byte一样才会发生），就抛弃st，同理，substring如果包含在st中，我们也要抛弃substring</li><li>如果st和substring有重叠，修改substring（可能修改st会更好，但这也可以过）</li></ul></li><li>检查是否存在已排序完成的部分（全部情况都需要这个检查）。类似消消乐，循环直到发现第一个无法被推入的位置。</li><li>检查是否结束</li></ul><h3 id="关键源码"><a href="#关键源码" class="headerlink" title="关键源码"></a>关键源码</h3><p>重新写过的代码的思路较为清晰，有较为详细的注释。感觉这种码风主要继承于xv6，而不像c++的风格。（虽然用到了一些modern c++）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// in reassembler.cc</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;reassembler.hh&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::update</span><span class="hljs-params">(substring &amp;st)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// since we will handler overlap every time,</span><br>  <span class="hljs-comment">// we assume overlaping substrings dont exist.</span><br><br>  <span class="hljs-comment">// 1.find the pos and insert.</span><br>  list&lt;substring&gt;::iterator it = substrings.<span class="hljs-built_in">begin</span>();<br>  list&lt;substring&gt;::iterator backit = substrings.<span class="hljs-built_in">begin</span>();<br>  list&lt;substring&gt;::iterator fowdit = substrings.<span class="hljs-built_in">begin</span>();<br><br>  <span class="hljs-keyword">for</span>(; it != substrings.<span class="hljs-built_in">end</span>(); it++)<br>    <span class="hljs-keyword">if</span>((*it).first_byte &gt;= st.first_byte)<br>      <span class="hljs-keyword">break</span>;<br>  it = substrings.<span class="hljs-built_in">insert</span>(it, st);<br><br>  <span class="hljs-comment">// 2.check the substring before pos.</span><br>  <span class="hljs-keyword">if</span>(it != substrings.<span class="hljs-built_in">begin</span>())&#123;<br>    backit = it;<br>    backit --;<br><br>    substring t = (*backit);<br>    <span class="hljs-comment">// case 1: st totally inside the substring. delete the st.</span><br>    <span class="hljs-keyword">if</span>((*backit).first_byte + (*backit).data.<span class="hljs-built_in">size</span>() &gt;= st.first_byte + st.data.<span class="hljs-built_in">size</span>())&#123;<br>      substrings.<span class="hljs-built_in">erase</span>(it);<br>      <span class="hljs-keyword">goto</span> push;<br>    &#125;<br><br>    <span class="hljs-comment">// case 2: st overlap part of it. edit the substring.</span><br>    <span class="hljs-keyword">if</span>((*backit).first_byte + (*backit).data.<span class="hljs-built_in">size</span>() &lt; st.first_byte + st.data.<span class="hljs-built_in">size</span>())&#123;<br>      (*backit).data = (*backit).data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, st.first_byte - (*backit).first_byte);<br>    &#125;<br><br>    <span class="hljs-comment">// case 3: no overlap. do nothing.</span><br>  &#125;<br><br><br>  <span class="hljs-comment">// 3.check the substring after pos.</span><br>  <span class="hljs-keyword">if</span>(it == substrings.<span class="hljs-built_in">end</span>())<br>    <span class="hljs-keyword">goto</span> push;<br><br>  fowdit = it;<br>  fowdit++;<br>  <span class="hljs-keyword">for</span>(; fowdit != substrings.<span class="hljs-built_in">end</span>();)&#123;<br>    <span class="hljs-comment">// case 1: no overlap. </span><br>    <span class="hljs-keyword">if</span>((*fowdit).first_byte &gt;= st.first_byte + st.data.<span class="hljs-built_in">size</span>())<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// case 2: st totally inside the substring. delete the st.</span><br>    <span class="hljs-keyword">if</span>((*fowdit).first_byte == st.first_byte &amp;&amp; (*fowdit).data.<span class="hljs-built_in">size</span>() &gt;= st.data.<span class="hljs-built_in">size</span>())&#123;<br>      substrings.<span class="hljs-built_in">erase</span>(it);<br>      <span class="hljs-keyword">goto</span> push;<br>    &#125;<br><br>    <span class="hljs-comment">// case 3: substring totally inside the st. delete the substring.</span><br>    <span class="hljs-keyword">if</span>((*fowdit).first_byte + (*fowdit).data.<span class="hljs-built_in">size</span>() &lt;= st.first_byte + st.data.<span class="hljs-built_in">size</span>())&#123;<br>      fowdit = substrings.<span class="hljs-built_in">erase</span>(fowdit);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// case 4: st overlap part of it. edit the substring.</span><br>    <span class="hljs-keyword">if</span>((*fowdit).first_byte + (*fowdit).data.<span class="hljs-built_in">size</span>() &gt; st.first_byte + st.data.<span class="hljs-built_in">size</span>())&#123;<br>      (*fowdit).data = (*fowdit).data.<span class="hljs-built_in">substr</span>(st.first_byte + st.data.<span class="hljs-built_in">size</span>() - (*fowdit).first_byte);<br>      (*fowdit).first_byte = st.first_byte + st.data.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    fowdit++;<br>  &#125;<br><br>push:<br>  <span class="hljs-comment">// 4.scan the list and push possible substrings</span><br>  substring t;<br>  <span class="hljs-keyword">while</span>(!substrings.<span class="hljs-built_in">empty</span>())&#123;<br>    t = substrings.<span class="hljs-built_in">front</span>();<br><br>    <span class="hljs-keyword">if</span>(t.first_byte == next_byte)&#123;<br>      output_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">push</span>(t.data);<br>      next_byte += t.data.<span class="hljs-built_in">size</span>();<br>      substrings.<span class="hljs-built_in">pop_front</span>();<br>    &#125; <span class="hljs-keyword">else</span> <br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(t.first_byte + t.data.<span class="hljs-built_in">size</span>() == finish_index &amp;&amp; substrings.<span class="hljs-built_in">empty</span>())&#123;<br>    output_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">close</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reassembler::insert</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> first_index, string data, <span class="hljs-type">bool</span> is_last_substring )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// pack it up.</span><br>  substring st;<br>  st.first_byte = first_index;<br>  st.is_last_substring = is_last_substring;<br>  st.data = data;<br><br>  <span class="hljs-comment">// get the finish byte index</span><br>  <span class="hljs-keyword">if</span>(st.is_last_substring)&#123;<br>    finish_index = first_index + data.<span class="hljs-built_in">size</span>();<br>  &#125;<br>  <span class="hljs-comment">// if the substring totally outside the available area, discarded.</span><br>  <span class="hljs-keyword">if</span>(first_index + data.<span class="hljs-built_in">size</span>() &lt; next_byte || first_index &gt;= <span class="hljs-built_in">unaccept_index</span>())&#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// if no space for substring, discarded.</span><br>  <span class="hljs-keyword">if</span>(next_byte == <span class="hljs-built_in">unaccept_index</span>())<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">// if the substring have bytes outside the available area, cut it.</span><br>  <span class="hljs-comment">// case 1: head outbound.</span><br>  <span class="hljs-keyword">if</span>(st.first_byte &lt; next_byte)&#123;<br>    st.data = st.data.<span class="hljs-built_in">substr</span>(next_byte - st.first_byte);<br>    st.first_byte = next_byte;<br>  &#125;<br><br>  <span class="hljs-comment">// case 2: tail outside.</span><br>  <span class="hljs-keyword">if</span>(st.first_byte + st.data.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-built_in">unaccept_index</span>())&#123;<br>    st.data = st.data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">unaccept_index</span>() - st.first_byte);<br>    st.is_last_substring = <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// finish process, push into the list.</span><br>  <span class="hljs-built_in">update</span>(st);<br><br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::bytes_pending</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> used_bytes = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span>(substring i: substrings)&#123;<br>    used_bytes += i.data.<span class="hljs-built_in">size</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> used_bytes;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::unpopped_index</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> output_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">bytes_pushed</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reassembler::unaccept_index</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> next_byte + output_.<span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结-经验"><a href="#总结-经验" class="headerlink" title="总结&#x2F;经验"></a>总结&#x2F;经验</h2><p>其实第二次写的代码还是在同一个地方出错了，但这次的debug方法是：</p><p>在<code>minnow/build</code>的目录下执行：</p><p><code>ctest -R &#39;^reassembler_speed_test$&#39;</code></p><p>查看<code>minnow/build/Testing/Temporary/LastTest.log</code>，搭配上在<code>reassembler.cc</code>中输出的调试信息（上面的源码已经删掉），发现了问题。</p><p>期间发现的一些重大错误包括但不限于：</p><ul><li><code>backit == it++</code>：忘记了it的值已经改变</li><li>在insert中，对于头部尾部都超出范围的处理，与自己的预期不一样，是没用修改后的st来判断导致的。</li></ul><p>总用时：2-3天（不熟悉c++导致的）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS144-check0</title>
    <link href="/2024/09/12/CS144-check0/"/>
    <url>/2024/09/12/CS144-check0/</url>
    
    <content type="html"><![CDATA[<h1 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h1><blockquote><p>macos用户指北</p></blockquote><ul><li>安装utm和下载官方<strong>对应</strong>的压缩包，解压后在utm中打开</li><li>我的虚拟机默认没有打开端口？（不清楚具体的原理），通过google学习后，在utm的虚拟机的设置中，找到network，将<strong>network mode</strong>变成<strong>Emulated Vlan</strong>，这时候会出现port的选项，进去将guest port设为22， host port设为2222。</li><li>在mac的终端，现在就可以通过ssh连接了，<code>ssh -p 2222 cs144@localhost</code>。</li></ul><h1 id="networking-by-hand"><a href="#networking-by-hand" class="headerlink" title="networking by hand"></a>networking by hand</h1><p>按照要求去玩一下，但后面需要校内学生帐号。</p><h1 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h1><p>因为用vim太麻烦，不方便搞project，查了一下，可以使用ssh，将vscode连接虚拟主机，按照vscode官方的文档（连接时的命令一定是上面那一条），就可以连上，在物理机的vscode就可以打开虚拟机的文件夹并操作了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_URL</span><span class="hljs-params">( <span class="hljs-type">const</span> string&amp; host, <span class="hljs-type">const</span> string&amp; path )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//cerr &lt;&lt; &quot;Function called: get_URL(&quot; &lt;&lt; host &lt;&lt; &quot;, &quot; &lt;&lt; path &lt;&lt; &quot;)\n&quot;;</span><br>  TCPSocket tcp_socket;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Address <span class="hljs-title">host_addr</span><span class="hljs-params">(host, <span class="hljs-string">&quot;http&quot;</span>)</span></span>;<br>  <br>  tcp_socket.<span class="hljs-built_in">connect</span>(host_addr);<br><br>  <span class="hljs-type">const</span> string request = <span class="hljs-string">&quot;GET &quot;</span>+path+<span class="hljs-string">&quot; HTTP/1.1\r\nHost:&quot;</span>+host+<span class="hljs-string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>; <br>  tcp_socket.<span class="hljs-built_in">write</span>(request);<br><br>  <span class="hljs-keyword">while</span>(!tcp_socket.<span class="hljs-built_in">eof</span>()) &#123;<br>    string buf;<br>    tcp_socket.<span class="hljs-built_in">read</span>(buf);<br>    cout &lt;&lt; buf;<br>  &#125;<br>  tcp_socket.<span class="hljs-built_in">close</span>();<br>  <span class="hljs-comment">//cerr &lt;&lt; &quot;Warning: get_URL() has not been implemented yet.\n&quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>刚好10行（不算括号）。</p><h1 id="byte-stream"><a href="#byte-stream" class="headerlink" title="byte stream"></a>byte stream</h1><p>开始我的byte stream是用string来存的，顺利通过了前7个测试，但到了<code>stress_test</code>的时候超时了，猜测应该是过多的字符串的复制修改导致的，所以试图寻找c++ std里面更快的数据结构。</p><p>然而在边用queue边调错时发现，导致超时的原因压根不是string的复制操作效率过低，而是理解错了peek的意思，并不是只传首个字节，而是要将buffer将只读的方法传回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// byte_stream.hh</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteStream</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ByteStream</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> capacity )</span></span>;<br><br>  <span class="hljs-comment">// Helper functions (provided) to access the ByteStream&#x27;s Reader and Writer interfaces</span><br>  <span class="hljs-function">Reader&amp; <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Reader&amp; <span class="hljs-title">reader</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">Writer&amp; <span class="hljs-title">writer</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Writer&amp; <span class="hljs-title">writer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_error</span><span class="hljs-params">()</span> </span>&#123; error_ = <span class="hljs-literal">true</span>; &#125;;       <span class="hljs-comment">// Signal that the stream suffered an error.</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">has_error</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> error_; &#125;; <span class="hljs-comment">// Has the stream had an error?</span><br><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-comment">// Please add any additional state to the ByteStream here, and not to the Writer and Reader interfaces.</span><br>  std::string buffer_&#123;&#125;;<br>  <span class="hljs-type">uint64_t</span> capacity_;<br>  <span class="hljs-type">uint64_t</span> bytes_pushed_&#123;&#125;;<br>  <span class="hljs-type">uint64_t</span> bytes_popped_&#123;&#125;;<br>  <span class="hljs-type">bool</span> error_ &#123;&#125;;<br>  <span class="hljs-type">bool</span> closed_&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还是折腾了一会。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// byte_stream.cc</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;byte_stream.hh&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>ByteStream::<span class="hljs-built_in">ByteStream</span>( <span class="hljs-type">uint64_t</span> capacity ) : <span class="hljs-built_in">capacity_</span>( capacity ) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Writer::is_closed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">writer</span>().closed_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::push</span><span class="hljs-params">( string data )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> cap = <span class="hljs-built_in">writer</span>().<span class="hljs-built_in">available_capacity</span>();<br>  <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">length</span>() &gt; cap)<br>  &#123;<br>    data = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, cap);<br>  &#125; <br>  <br>  <span class="hljs-built_in">writer</span>().buffer_ += data;<br>  <span class="hljs-built_in">writer</span>().bytes_pushed_ += data.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Writer::close</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">writer</span>().closed_ = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::available_capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-built_in">writer</span>().capacity_ - <span class="hljs-built_in">writer</span>().buffer_.<span class="hljs-built_in">size</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Writer::bytes_pushed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">writer</span>().bytes_pushed_;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Reader::is_finished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">bool</span> b = (<span class="hljs-built_in">reader</span>().buffer_.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>? <span class="hljs-literal">true</span>: <span class="hljs-literal">false</span>) <br>    &amp;&amp; (<span class="hljs-built_in">reader</span>().closed_);<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_popped</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reader</span>().bytes_popped_;<br>&#125;<br><br><span class="hljs-function">string_view <span class="hljs-title">Reader::peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  string_view view = <span class="hljs-built_in">reader</span>().buffer_;<br>  <span class="hljs-keyword">return</span> view;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reader::pop</span><span class="hljs-params">( <span class="hljs-type">uint64_t</span> len )</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-built_in">reader</span>().buffer_ = <span class="hljs-built_in">reader</span>().buffer_.<span class="hljs-built_in">substr</span>(len);<br>  <span class="hljs-built_in">reader</span>().bytes_popped_ += len;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">uint64_t</span> <span class="hljs-title">Reader::bytes_buffered</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// Your code here.</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">reader</span>().buffer_.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>check0算是热身，不需要特别了解网络的工作机制就可以实现。对于我来说，主要的时间是在熟悉c++的语法和思想，尽量去模仿框架代码的风格。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络：运输层</title>
    <link href="/2024/09/12/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2024/09/12/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>运输层负责将应用层的报文(message)，切分为多份并分别打包成<strong>报文段</strong>(segment)，然后传递给网路层。TCP和UDP即为运输层协议。</p><p>网络层协议为<strong>IP</strong>，服务方式为<strong>尽力而为</strong>，但不保证任何东西。</p><h2 id="多路"><a href="#多路" class="headerlink" title="多路"></a>多路</h2><p>由于一台主机上会有多个进程使用socket，所以要思考怎么实现正确的包装和交付。</p><h3 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h3><p>segment中有几个字段，接收端的运输层检查这些字段，识别出socket并将数据交付到达该socket。</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>从主机的不同socket收集数据块，并为每个数据块封装上首部的信息，生成segment，再将其传递到网络层。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>segment：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haskell">&lt;-------------------32bit--------------------&gt;<br>[source_port_number | destination_port_number]<br>[other_header]<br>[<span class="hljs-class"><span class="hljs-keyword">data</span>]</span><br></code></pre></td></tr></table></figure><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>为什么会选择udp？</p><ul><li>因为udp本身对数据没什么控制，与tcp不同。应用层可以更精细地控制</li><li>无需连接时间</li><li>无连接状态</li><li>首部开销小</li></ul><p>像视频通话、电话这种可以容忍丢包的应用，使用udp会更合适</p><p>udp的segment：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm">&lt;-<span class="hljs-comment">--------32bits---------&gt;</span><br>[source_<span class="hljs-keyword">port</span> | desti_port]<br>[  length    |  checksum ]<br>[         data           ]<br></code></pre></td></tr></table></figure><p>通过校验和(checksum)，udp在运输层提供差错检测，但无法恢复差错，只能丢弃问题的segment并发出警告。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>可以先去看看后面的可靠数据传输原理。</p><p>客户与服务器的TCP连接需要<strong>三次握手</strong>(three-way handshake)。用户通过socket将数据传递，接着数据被TCP控制，存到<strong>发送缓存</strong>(send buffer)中。</p><h3 id="TCP报文结构"><a href="#TCP报文结构" class="headerlink" title="TCP报文结构"></a>TCP报文结构</h3><p>其报文结构如下：</p><ul><li>Sequence number 即为segment的序列号</li><li>acknowledgment number 即为segment的确认号<blockquote><p>主机A填充进segment的确认号是主机A期望从主机B收到的下一字节的序号。</p></blockquote></li><li>Header length 用来表示报文头部的长度，当 Options 为空时，长度为20。</li><li>Flag field 包含6个bit。其中 ACK bit 表示应答客户端是否成功接收，RST，SYN，FIN 用于连接设置。</li><li>Receive window 用于流控制。</li></ul><h3 id="传输机制"><a href="#传输机制" class="headerlink" title="传输机制"></a>传输机制</h3><p>TCP采用超时重传机制。需要有往返时间估计的方法。</p><p><strong>RTT</strong>：TCP会在某个时刻通过发送样本RTT来测量往返时间。对于一个新测出来的RTT，会通过加权平均以前RTT的估计值和现在的RTT来更新现在RTT的估计值，再用DevRTT计算出超时间隔。</p><p>除了rbt3.0实现的基本功能外，大部分TCP还会进行以下的修改：</p><ul><li><strong>超时间隔加倍</strong>：实现了一定程度的拥塞控制。当发生超时时，有可能是路径上有过多的packet，而此时按照原来的超时间隔重发，可能会加剧拥塞</li><li><strong>快速重传</strong>：当接收方收到一个序号大于预期的segment，说明发生丢包，接收方会向发送方产生一个<strong>冗余ACK</strong>(duplicate ACK)。如果发送方收到相同数据的3个冗余ACK，会将它作为丢包的指示，执行快速重传。</li></ul><p>TCP还提供<strong>流量控制服务</strong>(flow-control service)，注意其与拥塞控制(congestion control)不同。前者本质是一个速度匹配服务，即使发送方的发送速率与接收方的读取速率相同。后者是因为ip网络的拥塞，而遏制发送方。</p><h3 id="TCP三次握手具体实现"><a href="#TCP三次握手具体实现" class="headerlink" title="TCP三次握手具体实现"></a>TCP三次握手具体实现</h3><ul><li><strong>第一步</strong>：发送SYN segment，在首部的SYN比特被置为1，序号字段为client_isn（客户随机选择的初始序号）。</li><li><strong>第二步</strong>：服务器收到SYN sesgment，为该tcp连接分配tcp缓存和变量（可能导致<strong>洪泛攻击</strong>），向客户端发送允许连接的SYNACK segment，该segment的SYN bit被设为1，确认号字段被设为client_isn+1，序号字段被设为server_isn。</li><li><strong>第三步</strong>：客户收到SYNACK segment，为该连接分配缓存和变量，发送segment，其确认字段被设为server_isn+1，SYN bit设为0，并且可以负载需要传输的数据。</li></ul><h3 id="TCP结束连接"><a href="#TCP结束连接" class="headerlink" title="TCP结束连接"></a>TCP结束连接</h3><p>当客户进程发出关闭连接的命令，用户的TCP发出一个FIN bit为1的segment，服务器接收到后发送ACK，接着也发送一个FIN bit为1的segment，最后客户接收并发送ACK，即完成全部连接资源的释放。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>TCP的拥塞控制机制需要额外跟踪一个变量，即<strong>拥塞窗口</strong>，用cwnd表示。假设TCP接收缓存足够大，即不会出现接收窗口大小限制发送速率，只考虑cwnd的限制。此时发送速率为<code>cwnd/RTT byte/s</code></p><p>TCP感知出现拥塞：出现超时&#x2F;收到3个冗余ACK</p><h3 id="TCP拥塞控制算法"><a href="#TCP拥塞控制算法" class="headerlink" title="TCP拥塞控制算法"></a>TCP拥塞控制算法</h3><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>TCP连接开始时，cwnd的值设为一个MSS，即发送速率为<code>MSS/RTT</code>，每当传输的segment都被确认，cwnd的大小加一倍。所以其实传输速率为指数增长，并不慢！</p><p>如果存在超时导致的丢包，则发送方将cwnd设为1并重新开始，将<strong>慢启动阈值</strong>(ssthresh)设为开始拥塞时的cwnd的一半。</p><p>当重新启动时，可能超过&#x2F;到达ssthresh，会结束慢启动模式，转到<strong>拥塞避免模式</strong>，更谨慎地增加cwnd</p><p>如果检测到3个冗余ACK，TCP执行快速重传并进入<strong>快速恢复模式</strong>。</p><h4 id="拥塞避免模式"><a href="#拥塞避免模式" class="headerlink" title="拥塞避免模式"></a>拥塞避免模式</h4><p>每个RTT只将cwnd的值加一个MSS，实现线性增长。结束增长和慢启动一样。不同的是，检测到3个冗余时，cwnd变为一半，将ssthresh记录为cwnd值的一半。</p><h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>对于引起TCP进入快速恢复状态的缺失segment，对于每个冗余ACKcwnd的值增加一个MSS。出现超时则和慢启动和拥塞避免一样。</p><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><h3 id="构造可靠数据传输协议"><a href="#构造可靠数据传输协议" class="headerlink" title="构造可靠数据传输协议"></a>构造可靠数据传输协议</h3><p>这里的实现比较复杂，通过rdt(reliable data transfer)协议3.0来体会各个部分的作用。注意这里使用状态机 + 伪代码的方法来描述。</p><p><code>rdt3.0</code> 是一个用于可靠数据传输的协议，主要应对 <strong>丢包</strong> 和 <strong>比特错误</strong> 的问题。它引入了超时机制、序列号和确认（ACK）机制来确保可靠性，基于 <code>rdt2.x</code> 的基础，增加了对丢包的处理。</p><p>以下是 <code>rdt3.0</code> 的伪代码描述，分为发送方和接收方。</p><h4 id="发送方的伪代码"><a href="#发送方的伪代码" class="headerlink" title="发送方的伪代码"></a>发送方的伪代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">state: WAIT_FOR_CALL_FROM_ABOVE<br><br>while true:<br>    if event == from_upper_layer:   // 从上层接收到数据<br>        create_packet(data, seq_num)   // 创建数据包，包含数据和序列号<br>        send(packet)   // 发送数据包<br>        start_timer()   // 开始定时器<br>        state = WAIT_FOR_ACK<br><br>state: WAIT_FOR_ACK<br><br>while true:<br>    if event == timeout:   // 超时未收到 ACK<br>        resend(packet)   // 重新发送数据包<br>        start_timer()   // 重启定时器<br>    <br>    if event == receive_ACK and is_corrupt(ACK) == false:<br>        if ack_seq_num == seq_num:   // 收到正确的 ACK<br>            stop_timer()<br>            seq_num = (seq_num + 1) % 2   // 切换序列号<br>            state = WAIT_FOR_CALL_FROM_ABOVE   // 返回等待上层调用状态<br></code></pre></td></tr></table></figure><h4 id="接收方的伪代码"><a href="#接收方的伪代码" class="headerlink" title="接收方的伪代码"></a>接收方的伪代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">state: WAIT_FOR_0_FROM_BELOW<br><br>while true:<br>    if event == receive_packet and is_corrupt(packet) == false:<br>        if packet.seq_num == 0:   // 收到序列号为 0 且未损坏的数据包<br>            deliver_data(packet.data)   // 传递数据到上层<br>            send_ACK(0)   // 发送 ACK 0<br>            state = WAIT_FOR_1_FROM_BELOW   // 切换到等待序列号 1 的状态<br>        else:<br>            send_ACK(1)   // 序列号不匹配，重复发送 ACK 1 表示之前已经收到过该包<br><br>    if event == receive_packet and is_corrupt(packet) == true:<br>        // 数据包损坏，忽略不做处理（自动依赖发送方超时重传）<br><br>state: WAIT_FOR_1_FROM_BELOW<br><br>while true:<br>    if event == receive_packet and is_corrupt(packet) == false:<br>        if packet.seq_num == 1:   // 收到序列号为 1 且未损坏的数据包<br>            deliver_data(packet.data)   // 传递数据到上层<br>            send_ACK(1)   // 发送 ACK 1<br>            state = WAIT_FOR_0_FROM_BELOW   // 切换到等待序列号 0 的状态<br>        else:<br>            send_ACK(0)   // 序列号不匹配，重复发送 ACK 0 表示之前已经收到过该包<br><br>    if event == receive_packet and is_corrupt(packet) == true:<br>        // 数据包损坏，忽略不做处理（自动依赖发送方超时重传）<br></code></pre></td></tr></table></figure><h4 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h4><ul><li><strong>序列号</strong>: 发送方和接收方使用 0 和 1 两个序列号来区分重复数据包。</li><li><strong>ACK（确认）</strong>: 接收方向发送方发送 ACK，表明接收到的数据包是正确的。</li><li><strong>超时重传</strong>: 发送方在一定时间内未收到 ACK 时，会重传数据包。</li></ul><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><p>rdt3.0本质为停等协议，我们希望在等一个packet的ACK时，可以同时发送其他packet，可以看作是将packet都填充到一个流水线上。实现需要增加以下机制：</p><ul><li>增加序号范围：显然之前的0和1是不够的，每个输送的packet都需要有一个唯一的序号</li><li>发送方缓存已发送但未确认的packet</li><li>选择处理丢包&#x2F;损失的方法：<strong>GBN</strong>(Go-Back-N)，<strong>SR</strong>(Seletive Repeat)</li></ul><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h3 id="拥塞原因"><a href="#拥塞原因" class="headerlink" title="拥塞原因"></a>拥塞原因</h3><ul><li>发送速度达到吞吐量上限</li><li>发生超时，重传分组过多导致。当持续升高发送速率，传输速率甚至可能不增加（重传分组也在增加），浪费了传输能力。</li><li>一个分组在一个路径上被舍弃掉时，在舍弃之前的传输容量被浪费了</li></ul><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ul><li><strong>端到端控制</strong>，端系统通过一些网络拥塞的迹象来决定拥塞控制</li><li><strong>网络辅助控制</strong>，路由器向发送方提供关于网络拥塞状态的显式信息。一般有两种反馈方式。第一种为直接反馈，直接向发送方发送<strong>阻塞分组</strong>。第二种为标记发送方到接收方的分组的某个字段来反馈。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络：应用层</title>
    <link href="/2024/09/12/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2024/09/12/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>在具体的讨论所有概念之前，需要先大致知道各个部分的关系是怎么样的。</p><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><p>应用程序研发者需要决定程序使用的体系结构，一般有以下两种：</p><h4 id="客户-服务器体系结构-client-server-architecture"><a href="#客户-服务器体系结构-client-server-architecture" class="headerlink" title="客户-服务器体系结构(client-server architecture)"></a>客户-服务器体系结构(client-server architecture)</h4><p>服务器接收来自用户的请求，发送所请求的对象。服务器具有固定的ip地址。</p><h4 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h4><p>成对间歇连接的主机彼此直接通信。P2P的体系结构具有自拓展性，随着对等方数量增加，分发时间只会趋于一定值，而非线形增长。原因是对等方不仅是消费者还是重新分发者。</p><p>BitTorrent是一种流行的P2P协议，具有一些高效机制，比如一方可以给传输速度最快的对等方优先权。</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>不同端系统上的进程通过交换<strong>报文</strong>来相互通信</p><h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><p>在一对进程，一个标识为客户，一个标识为服务器</p><h4 id="进程与计算机网络的接口"><a href="#进程与计算机网络的接口" class="headerlink" title="进程与计算机网络的接口"></a>进程与计算机网络的接口</h4><p>进程通过<strong>套接字</strong>(socket)来向网络发送报文&#x2F;接收报文</p><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><p>为了让报文可以送给指定主机的指定进程，需要<strong>IP地址</strong> + <strong>端口号</strong>(port number)</p><h3 id="运输服务"><a href="#运输服务" class="headerlink" title="运输服务"></a>运输服务</h3><p>可以从四个方面对应用程序服务要求分类：</p><ul><li>可靠数据传输</li><li>吞吐量</li><li>定时</li><li>安全性</li></ul><h3 id="internet提供的运输服务"><a href="#internet提供的运输服务" class="headerlink" title="internet提供的运输服务"></a>internet提供的运输服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP为一种面向连接的服务，在交换报文之前，会有握手阶段，即客户与服务器交换信息，完成该阶段才会建立TCP连接。</p><p>TCP确保了数据都是无差错并按顺序的。其拥有拥塞控制机制，当网络阻塞时，会抑制发送进程。</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>无连接，无拥塞机制，直接注入数据。</p><h2 id="web和http"><a href="#web和http" class="headerlink" title="web和http"></a>web和http</h2><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>http定义了web客户向服务器请求网页的方式。http使用TCP协议。客户和服务器都是通过socket与TCP连接，TCP为http提供可靠的数据传输服务。当用户试图请求一个网页，发生的过程如下：</p><ul><li>客户通过TCP向客户端发送http请求</li><li>客户端从TCP接收请求并发送http响应</li></ul><p>注意http为<strong>无状态协议</strong>，http服务器不会保存用户的任何信息。</p><p>同时，http既可以使用<strong>非持续连接</strong>，也可以使用<strong>持续连接</strong>。非持续连接，简单理解，即每个TCP连接在服务器发送了一个对象后关闭。持续连接，服务器在发送响应后，保持TCP连接打开。</p><p>http的请求报文<strong>格式</strong>：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">request line | <span class="hljs-keyword">method</span> <span class="hljs-title function_">url</span> <span class="hljs-title function_">version</span><br><span class="hljs-title function_">header</span> <span class="hljs-title function_">line</span>  | <span class="hljs-title function_">header_field_name</span> <span class="hljs-title function_">value</span><br>               <span class="hljs-title function_">header_field_name</span> <span class="hljs-title function_">value</span><br>               ...<br><span class="hljs-title function_">entity</span> <span class="hljs-title function_">body</span>  | ...<br><br></code></pre></td></tr></table></figure><p>比如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">GET /somedir/page.html HTTP/1.1<br><span class="hljs-section">HOST: www.someschool.edu</span><br><span class="hljs-section">Connection: close</span><br><span class="hljs-section">User-agent: Mozilla/5.0</span><br><span class="hljs-section">Accept-language: en</span><br>(data data ...)<br></code></pre></td></tr></table></figure><p>请求行（Request Line）中定义了 HTTP 请求的关键参数。其中 Method 字段表示请求的方式，常用的请求方式为GET，POST。URL 字段用来定位资源，Version 字段用来说明当前使用的协议版本。头部行（Header Lines）中定义了可选的参数，用来辅助 HTTP 请求。数据域（Entity Body） 用来传输数据。</p><p>http的响应报文格式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">status</span> <span class="hljs-selector-tag">line</span> | <span class="hljs-selector-tag">version</span> <span class="hljs-selector-tag">status_code</span> <span class="hljs-selector-tag">phrase</span><br><span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">line</span>  | <span class="hljs-selector-tag">header_field_name</span> <span class="hljs-selector-tag">value</span><br>               <span class="hljs-selector-tag">header_field_name</span> <span class="hljs-selector-tag">value</span><br>               ...<br><span class="hljs-selector-tag">entity</span> <span class="hljs-selector-tag">body</span>  | ...<br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">HTTP/1.1</span> <span class="hljs-number">200</span> <span class="hljs-string">OK</span><br><span class="hljs-attr">Connection:</span> <span class="hljs-string">close</span><br><span class="hljs-attr">Date:</span> <span class="hljs-string">Wed,</span> <span class="hljs-number">12</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2019 12:00:01 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">Server:</span> <span class="hljs-string">Apache/2.2.3</span><br><span class="hljs-attr">Last-Modified:</span> <span class="hljs-string">Wed,</span> <span class="hljs-number">12</span> <span class="hljs-string">Aug</span> <span class="hljs-number">2019 9:11:03 </span><span class="hljs-string">GMT</span><br><span class="hljs-attr">Content-Length:</span> <span class="hljs-number">6821</span><br><span class="hljs-attr">Content-Type:</span> <span class="hljs-string">text/html</span><br><span class="hljs-string">(data</span> <span class="hljs-string">data</span> <span class="hljs-string">...)</span><br></code></pre></td></tr></table></figure><p>字段说明：</p><p>状态行（Status Line）定义了响应报文的关键参数。其中 Version 用来说明当前使用的协议版本，Status Code 表示请求结果的状态码，phrase 为状态码的说明。</p><p>头部行（Header Lines）中定义了可选的参数，用来辅助 HTTP 响应。</p><p>数据域（Entity Body） 用来传输数据。</p><p>常见的状态码</p><ul><li>200 OK：请求成功。</li><li>301 Moved Permanently：资源位置永久移动，新的url在响应报文的location中。</li><li>400 Bad Request：错误的请求，通用的差错代码。</li><li>404 Not Found：请求的资源不存在服务器中。</li><li>505 HTTP Version Not Supported：HTTP 协议版本不支持。</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>前面的http服务器都是无状态的。如果想将内容与用户联系起来，可以让http使用cookie。为了支持cookie，需要修改4个地方：</p><ul><li>http响应报文加入cookie首部行</li><li>http请求报文加入cookie首部行</li><li>用户端系统保留一个文件</li><li>后端数据库保留信息</li></ul><h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>可以配置浏览器指向web缓存器，其实就是cache。web缓存器即是客户也是服务器。通过设置web缓存器可以减少用户的响应时间。但是会有新的问题，就是，当网站更新，其缓存并不会更新，导致客户请求的是旧的。</p><p><strong>条件GET</strong>方法，允许缓存器证实请求的对象是最新的。</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>也是用户层的协议，与http在同一层。http主要是一个<strong>拉协议</strong>，而smtp主要是一个<strong>推协议</strong>。在发邮件时会使用到smtp，而在试图访问邮件时（相当于你查看你的邮箱），需要<strong>POP3&#x2F;IMAP&#x2F;HTTP</strong>。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>(Domain Name System)。dns提供了将<strong>主机名</strong>到<strong>IP地址</strong>的转换的服务。包含了由<strong>DNS服务器</strong>实现的分布式数据库，和应用层协议（运行在udp上，端口为53）。</p><p>我们重新来访问一个网站，过程中发生以下事件：</p><ul><li>主机上运行着dns应用的客户端</li><li>浏览器从url提取主机名，传给dns客户端</li><li>dns客户端向dns服务器发送请求</li><li>dns客户端收到包含对应ip地址的回答报文</li><li>浏览器收到，向该ip地址发起连接</li></ul><h3 id="dns具体工作机理"><a href="#dns具体工作机理" class="headerlink" title="dns具体工作机理"></a>dns具体工作机理</h3><p>对于应用程序，如果需要将主机名转换为ip地址，只需要调用函数，比如<code>gethostbyname</code>，而dns的具体实现被抽象。下面来研究其机理。</p><p>dns的结构层次大概为以下：</p><ul><li>T0：<strong>根dns服务器</strong>：根服务器提供TLD服务器的ip地址</li><li>T1：<strong>TLD服务器</strong>：对于每个顶级域（如com、org、edu）和国家的顶级域（cn、uk、jp），都有TLD服务器。其提供权威dns服务器的ip地址</li><li>T2：<strong>权威dns服务器</strong>：所有公共可访问主机必须提供dns记录，权威dns服务器则收藏了这些dns记录。</li><li>T3：<strong>本地dns服务器</strong>：起到代理的作用，当主机发出dns请求时，将该请求转发到前几层。</li></ul><p>同样的，dns也具有缓存，使得大部分的dns查询可以绕过根服务器。</p><p>dns服务器上存储了<strong>资源记录</strong>(Resource Record)，每个dns回答报文中有多条RR，RR可以按下面的方法表示：</p><p><code>(name, value, type, ttl)</code></p><ul><li>type为A，则name是主机名，value为对应ip</li><li>type为NS，则name为域，value是知道 如何获取 该域的主机名的ip 的权威dns的主机名（有点绕）</li><li>type为CNAME，则value是别名为name的主机对应的规范主机名</li><li>type为MX，则value为别名为name的邮件服务器的规范主机名</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>为了向全世界用户分发巨量数据，大部分视频流公司都会用<strong>内容分发网</strong>(Content Distribution Network)。CDN管理多个服务器，在服务器存储视频和其他内容，将用户请求定向到较好的CDN的位置。</p><h3 id="CDN操作"><a href="#CDN操作" class="headerlink" title="CDN操作"></a>CDN操作</h3><p>当我们向网站请求一个视频（每个视频都有一个url）时：</p><ul><li>用户点击视频链接，发送对于视频网站的dns请求</li><li>LDNS将该dns转到权威dns服务器，但该权威服务器不返回ip地址，而是返回一个cdn服务器的主机名</li><li>用户的LDNS发送第二个请求给cdn服务器，并得到指定的cdn服务器</li><li>用户得到该cdn节点的ip地址，建立连接，发送请求</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Computer-Networking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统：并发</title>
    <link href="/2024/08/30/%E5%B9%B6%E5%8F%91/"/>
    <url>/2024/08/30/%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><p>多线程共享相同的地址空间，但有不同的程序计数器和栈。</p><p>并发会引发十分多糟糕的问题，且人类的线性思维，适合观测串行运行的程序而非并行运行的程序，所以处理并发十分困难。详细的例子可以看jyy的os课体验一下<a href="https://www.bilibili.com/video/BV1jx4y1S7cP/?share_source=copy_web&vd_source=a9e41a90f038945729e9b5aa11e0cbc6">并发互斥</a></p><p><strong>临界区</strong>，(critical section)是指访问共享资源的代码。当多个线程同时进入临界区时，可能就会出现<strong>竞争条件</strong>(race condition)，导致计算机运行的结果具有<strong>不确定性</strong>(indeterminate)。为了避免出现竞态，线程应该使用互斥(mutual exclusion)原语。</p><p>我们希望拥有一些原子指令，他们可以构建出通用的集合，以此构建多线程代码。</p><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// some basic api of thread</span><br><span class="hljs-comment">// to compile and exec multi-thread program:</span><br><span class="hljs-comment">// include pthread.h </span><br><span class="hljs-comment">// gcc ... -lpthread</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-comment">// to create a thread to start from function mythread</span><br><span class="hljs-comment">// and pass parameters args</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">mythread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br><span class="hljs-type">myret_t</span> *r;<br>...<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)r;<br>&#125;<br><span class="hljs-type">pthread_t</span> p;<br><span class="hljs-type">int</span> rc = pthread_create(&amp;p, <span class="hljs-literal">NULL</span>, mythread, &amp;args)<br><br><span class="hljs-comment">// to wait for thread to terminate</span><br><span class="hljs-type">myret_t</span> *m;<br>pthread_join(p, (<span class="hljs-type">void</span> **)&amp;m);<br><br><span class="hljs-comment">// to create a lock</span><br><span class="hljs-type">pthread_mutex_t</span> lock;<br><span class="hljs-type">int</span> r = pthread_mutex_init(&amp;lock, <span class="hljs-literal">NULL</span>);<br><br>pthread_mutex_lock(&amp;lock);<br>...<br>pthread_mutex_unlock(&amp;lock);<br><br><span class="hljs-comment">// other lock related function</span><br><span class="hljs-comment">// if lock is occupied, it failed</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span>;<br><span class="hljs-comment">// if request timeout, it failed</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_timedlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex, <span class="hljs-keyword">struct</span> timespec *abs_timeout)</span>;<br><br><span class="hljs-comment">// use condition variable for multi-thread</span><br><span class="hljs-type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_mutex_t</span> cond = PTHREAD_COND_INITIALIZER;<br><span class="hljs-comment">// thread1</span><br>pthread_mutex_lock(&amp;lock);<br><span class="hljs-keyword">while</span>(ready == <span class="hljs-number">0</span>)<br>pthread_cond_wait(&amp;cond, &amp;lock);<br>pthread_mutex_unlock(&amp;lock);<br><span class="hljs-comment">// thread2</span><br>pthread_mutex_lock(&amp;lock);<br>ready = <span class="hljs-number">1</span>;<br>pthread_cond_signal(&amp;cond);<br>pthread_mutex_unlock(&amp;lock);<br><br><br></code></pre></td></tr></table></figure><h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><p>最开始解决互斥的方案之一，是试图关闭中断。这种方法虽然简单但显然存在很多问题。比如出现恶意程序关闭中断并死循环，或者多处理器，等等。</p><p>显然用户不可以有暂停时间的权限，但操作系统可以有。我们可以编写一些原子指令来实现。</p><h2 id="原子指令"><a href="#原子指令" class="headerlink" title="原子指令"></a>原子指令</h2><p>一些基本的硬件支持的指令</p><ul><li><strong>test-and-set</strong>：检查标志是否为1，并设置为1</li><li><strong>compare-and-exchange</strong>：比较两个值并更新值</li><li><strong>load-link + store-condition</strong>：条件式存储判断在加载地址链接某个值后，该值有无变化，若无，才会成功。</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁，通过一直自旋，利用CPU周期直到锁可用。显然，如果持有锁的线程发生上下文切换，其他线程就只能一直自旋，等待该进程，浪费过多的资源和时间。有以下的解决方法。</p><h3 id="放弃"><a href="#放弃" class="headerlink" title="放弃"></a>放弃</h3><p>当将要自旋时，线程可以主动放弃cpu，通过调用yield。但是，这样无法解决starving的问题，即可能导致进程处于让出的循环，直到其中一个线程终于释放锁。</p><h3 id="队列-休眠"><a href="#队列-休眠" class="headerlink" title="队列+休眠"></a>队列+休眠</h3><p>简单来说，我们可以通过队列来实现合理的调度，决定锁释放时谁抢到锁。核心思想是，在设置锁时，当多个线程同时竞争一把锁，未获得锁的线程会将自己加入队列并进入休眠。在释放锁时，会通过队列顺序来唤醒下一个线程。</p><p>值得注意的是，如果在进入休眠前，恰好锁释放了，可能导致该线程永久休眠，即wakeup&#x2F;waiting race。可以添加新的调用，即表明自己即将要休眠，若刚好在休眠前调用了唤醒，该线程在进入休眠后会立即返回。</p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><p>很多情况下，为了实现同步，线程常常检查某一条件满足之后才会继续运行。在之前的实现中，我们可以通过自旋锁来完成，但显然在浪费cpu的时间。所以我们希望<em>让未满足条件的进程休眠，直至条件满足时被唤醒</em>。</p><p>我们可以声明条件变量，并通过wait()还有signal()的操作，来使该线程休眠等待，或者唤醒另一个线程。</p><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h2><p>描述一个模型：生产者负责将数据放入缓冲区，消费者负责将数据从缓冲区取走。两者都是线程。在执行的过程中，显然生产者的<em>条件</em>为缓冲区不满，消费者的<em>条件</em>为缓冲区不空，若不满足，可以通过上面的机制解决。真的吗？有什么要注意的问题？</p><h3 id="why-while"><a href="#why-while" class="headerlink" title="why while"></a>why while</h3><p>思考一下，如果我们用if来判断是否满足条件，判断出不满足时进入if让进程休眠，满足的话继续执行，最后唤醒其他进程。这在消费者和生产者都只有一个时，似乎可行，但如果消费者有两个呢？</p><p>若在一开始，缓冲区为空，两个消费者都进入了休眠状态。生产者填满了缓冲区，唤醒了消费者1，当消费者1就绪，正准备运行（从休眠处），消费者2抢先取数据（此时1还没有锁保护），轮到1时，1获取了锁，然后返回，但缓冲区已空。</p><p>上面的例子说明，当进程被唤醒时，只能<em>暗示有状态发生变化</em>，而不能推测在<em>执行前条件一直满足</em>。其次，用while代替if来判断是一个更好的选择。</p><p>还有问题吗？</p><h3 id="more-condition-variables"><a href="#more-condition-variables" class="headerlink" title="more condition variables"></a>more condition variables</h3><p>不止上面的问题呢，想象一下，还是上面的场景，但我们已经把if换成while了。当消费者1取数据，显然这时2因为不满足条件，休眠了。1取完后，发送信号唤醒一个进程。问题来了，好像可能会把2给叫醒，2醒来发现条件还是不满足，继续睡了。结果是三个线程全部进入了休眠。</p><p>解决该问题的方法也很简单，通过两个变量，来保证信号的指向性，消费者发送信号1，接受信号2，生产者发送信号2，接受信号1。</p><h3 id="covering-condition"><a href="#covering-condition" class="headerlink" title="covering condition"></a>covering condition</h3><p>覆盖条件。当不知道唤醒哪个线程可以满足条件时，考虑唤醒所有等待线程。即可以覆盖所有需要唤醒线程的场景。在单个变量的生产者&#x2F;消费者问题中，这是可行的。但如果程序只有改成广播信号，才能工作，大概率是程序本身有问题。（？</p><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量为一个整数。可以通过wait()和post()来操作它。可以初始化信号量的值。wait的功能为令信号量减1，如果信号量小于0，就休眠。post为令信号量加一，唤醒等待线程。先假设信号量的变化都是原子的。</p><h2 id="二值信号量"><a href="#二值信号量" class="headerlink" title="二值信号量"></a>二值信号量</h2><p>顾名思义，信号量开始时为1。第一个接触信号量的线程1，将其变为0并运行。在其结束前，其他试图进入临界区的线程，将信号量减为-1，等待。直到线程1释放锁信号量为0。如果结束前都没有其他线程访问临界区，信号量会恢复成1。这样就可以用于构成一般的锁。</p><h2 id="信号量作条件变量"><a href="#信号量作条件变量" class="headerlink" title="信号量作条件变量"></a>信号量作条件变量</h2><p>用于使线程暂停运行等待条件成立。信号量的初值设为0。假设一个线程1创建线程2并等待其结束。若创建后2并不开始运行，则1会将信号量减为-1并开始等待，直到2将信号量增加为0。如果2立即开始运行，2结束前信号量都为-1，1不会运行，结束后2就可以运行了。</p><h2 id="生产者-消费者问题-1"><a href="#生产者-消费者问题-1" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h2><p>实现其实在之前就写了，无非将对应的方法用信号量代替。但注意，如果我们在条件变量的外面加上锁，可能会导致<strong>死锁</strong>。比如，消费者持有锁，但在等消费的条件，当生产者试图运行时，因为没有锁，又进入等待。解决的方法就是缩小锁的范围，在条件变量内上锁。</p><h2 id="读者-写者锁"><a href="#读者-写者锁" class="headerlink" title="读者-写者锁"></a>读者-写者锁</h2><p>mian idea是，写者和读者间显然只能有一把锁，但一旦有一个读者拿到锁，其他读者也可以使用。（因为读并不会修改状态）。写者需要等待所有的读者结束后才能开始，所以可能会导致starving。</p><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>假设有5个哲学家围在圆桌，两个哲学家之间放着一个餐具，每个哲学家需要左右手都拿到餐具才能开始吃饭。我们给餐具上锁，所以拿餐具的过程是原子的。若所有哲学家的策略都是一样的，先拿左手边的餐具，若恰好他们都拿到了左手边的餐具，都在等右手的，这时就会都阻塞。</p><p>一种可行的解决方法是，让其中一人先取右边，来破除这种依赖。</p><h1 id="常见并发问题"><a href="#常见并发问题" class="headerlink" title="常见并发问题"></a>常见并发问题</h1><h2 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h2><p>该问题占了并发问题的大部分，主要讨论以下的内容</p><h3 id="违反原子性"><a href="#违反原子性" class="headerlink" title="违反原子性"></a>违反原子性</h3><p>指的是代码的愿意是原子的，然而并未按照原子性的实现。比如不加原子保护，判断一个指针非空后，试图访问改地址，有可能在访问时该指针已被其他线程变为空了。修复方法之一，就是加锁。</p><h3 id="违反顺序"><a href="#违反顺序" class="headerlink" title="违反顺序"></a>违反顺序</h3><p>指的是预期访问内存的顺序被打破（多线程的不确定性），导致的缺陷。显然，通过强制顺序来修复该缺陷，比如用条件变量来同步。</p><h2 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h2><h3 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h3><p>以下四个条件，只要一个不满足，死锁就不会产生：</p><ul><li><strong>互斥</strong>：比如需要抢锁</li><li><strong>持有并等待</strong>：线程持有资源（如：锁），又在等待其他资源（如：需要的另一把锁）</li><li><strong>非抢占</strong>：线程获得的资源，不能被抢占</li><li><strong>循环等待</strong>：线程形成环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程需要的</li></ul><p>所以我们可以考虑四种策略，每种策略都试图阻止一个条件，从而避免死锁</p><h4 id="预防循环等待"><a href="#预防循环等待" class="headerlink" title="预防循环等待"></a>预防循环等待</h4><p>一个想法是，规定锁的获取必须有顺序。一种顺序叫全序(total ordering)，即全部锁都会按照一定的先后顺序获取，必须先申请锁1，才能申请锁2。然而在复杂的系统中，这可能很难做到，所以可以采用偏序(partial ordering)，仅包含所有锁中的几个锁的关系。</p><h4 id="预防持有等待"><a href="#预防持有等待" class="headerlink" title="预防持有等待"></a>预防持有等待</h4><p>可以原子抢锁来避免，原子地抢多个锁。然而这需要知道所需的全部锁，不适合封装，降低了并发。</p><h4 id="预防非抢占"><a href="#预防非抢占" class="headerlink" title="预防非抢占"></a>预防非抢占</h4><p>我们可以让线程在抢到锁1，抢不到锁2时，主动放出锁1。</p><p>值得注意的是，如果另一个线程的抢锁顺序不同，比如先2后1，可能会导致<strong>活锁</strong>，他们同时抢锁失败，一直循环。</p><p>这种方法的封装性一般，若代码在途中获得其他资源（比如内存），必须也要确保他们被释放。</p><h4 id="预防互斥"><a href="#预防互斥" class="headerlink" title="预防互斥"></a>预防互斥</h4><p>不用锁，而使用硬件支持的原子操作。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>除了死锁的预防，我们还可以通过调度来避免死锁。让不竞争资源的线程并行运行，竞争的串行。</p><h3 id="检查-恢复"><a href="#检查-恢复" class="headerlink" title="检查&#x2F;恢复"></a>检查&#x2F;恢复</h3><p>允许死锁发生，采用死锁的检测和恢复技术。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统：内存虚拟化</title>
    <link href="/2024/08/30/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2024/08/30/%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>虚拟内存具有以下目标：</p><ul><li>透明：即程序会被欺骗得很好</li><li>效率：在虚拟化时，为了提高效率，需要硬件支持</li><li>保护：确保各个进程的隔离</li></ul><h1 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h1><p>先从简单的机制入手（后面会更复杂）</p><h2 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h2><p>基于硬件，最简单的重定位。每个cpu需要加入两个硬件寄存器：<strong>base</strong>和<strong>bound</strong>。当程序执行时，操作系统会决定其基址，设置base寄存器，然后该进程的所有进程引用都会被处理为物理地址：</p><p><code>paddr = vaddr + base</code></p><p>bound寄存器则提供了保护机制，当进程试图越界，会触发异常处理。</p><p>十分明显，这种方法效率低下，进程可能浪费大量内存。</p><h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>为了解决上面的问题，我们引入分段的机制。每个段都记录基址，以及界限。则处理地址的过程可以变为：</p><p><code>paddr = bias + base</code></p><p>偏移量可以通过虚拟地址计算出来。可以用虚拟地址的前几位来表示目标段：</p><p><code>[ s1 | s0 | v11 | ... | v0 ]</code></p><p>注意到栈的机制，我们不可以直接用虚拟地址来当偏移量，可以再增加一位用来记录是否反向增长。</p><p>该机制还可以提高保护，比如再引进一位用来记录段的权限。</p><p>物理内存的一个段可以映射到多个虚拟地址空间。</p><p>但该方法无法避免内存碎片，只能减少。需要更好的机制。</p><h1 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h1><p>先考虑外部碎片，即由于空闲空间大小不一，导致总空闲空间足够，但因为不连续而导致无法分配。</p><p>主要讲了一些合并与寻找空闲块的策略。</p><h2 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h2><ul><li>最优匹配：找候选块最小的可满足的，减少碎片大小</li><li>最差匹配：找候选最大的，留大块碎片（通常糟糕）</li><li>首次匹配：找第一个符合的，速度快</li><li>下次匹配：从上次分配的位置接着往后找</li></ul><h2 id="分离空闲列表"><a href="#分离空闲列表" class="headerlink" title="分离空闲列表"></a>分离空闲列表</h2><p>（不是很理解）</p><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>将空闲空间一直二分，直到满足。这样释放的时候，检查伙伴的块，可以实现递归合并。且由于这种机制，一对伙伴之间的地址关系很显然：他们只有一位不同。</p><h1 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h1><p>前面分段的方法，将空间切分成长度不同的部分，造成碎片。我们可以试试将物理内存定长分割，每一块叫做<strong>页</strong>。这种方法抽象程度更高，通过虚拟页与物理页映射，不用考虑进程怎么使用地址。</p><p>通过<strong>页表</strong>，实现虚拟页号（VPN）到物理页号（PFN）的转换。页表记录vpn与pfn的映射关系。比如：<br><code>[vpn|offset] -&gt; [pfn|offset]</code>实际上就完成了地址的转换。</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>在哪？我们可以建立一个<strong>页表基址寄存器</strong>(PTBR)来记录。现在我们可以用伪代码来模拟这个过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// extract vpn</span><br>vpn = (vaddr &amp; vpn_mask) &gt;&gt; shift<br><br><span class="hljs-comment">// get pte</span><br>pte_addr = ptbr + vpn * <span class="hljs-keyword">sizeof</span>(pte)<br>pte = M(pte_addr)<br><br><span class="hljs-comment">// check if can process page</span><br><span class="hljs-keyword">if</span>(pte.valid == <span class="hljs-literal">false</span>)<br>error(segmentation fault)<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pte.ifprotect == <span class="hljs-literal">true</span>)<br>error(protection fault)<br><span class="hljs-keyword">else</span><br>offset = vpn &amp; offset_mask<br>paddr = (pte.pfn &lt;&lt; shift) | offset<br>r = M(paddr)<br></code></pre></td></tr></table></figure><h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><p>由学过的储存器层次结构，caching是一种能加速内存访问的技术，应用于页表，就是TLB。TLB将前面的PTE表项拿来作为表项。</p><p>处理未命中时，系统抛出异常，加载更新TLB，再回到指令处重新执行。注意并非下一条指令，与之前讲的中断不一样。同时要注意无限递归，即异常处理程序本身不在TLB中。TLB为全相联的结构，所以可以直接并行查找，速度快。</p><p>因为不同的进程映射关系不同，理论上上下文切换时，应该清空TLB，但这样开销太大，可以考虑为TLB加上地址空间标识符（ASID）</p><p>一些替换策略：</p><ul><li>LRU</li><li>随机：避免上面方法的抖动现象</li></ul><h2 id="更小的页表"><a href="#更小的页表" class="headerlink" title="更小的页表"></a>更小的页表</h2><p>从上面知道，页表的项数为：2的 分配给页表的位数 次方，显然，页表本身为一笔不小的开销。我们思考以下方法：</p><p><strong>更大的页</strong>：通过减少vpn的位数从而减少页表，但内部碎片过大</p><p><strong>分段分页混合</strong>：我们不为整个进程提供页表，只对三个逻辑分段提供。之前每段都有一对基址界限寄存器，现在让基址寄存器记录该段的页表上的位置，界限记录有多少有效页。</p><p><strong>多级页表</strong>：本质就是将之前的页表分成页，用高一级的页表记录。好处是，当有一个<strong>页</strong>的页表项没有记录东西，我们可以在高一级的页表上用有效为0的表项来表示，从而避免给空页表分配空间。如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">[   vpn     |   <span class="hljs-type">offset</span>  ]<br>[ pti | <span class="hljs-type">pfn</span> |   <span class="hljs-type">offset</span>  ]<br>[pd1|<span class="hljs-type">pd0</span>|<span class="hljs-type">pfn</span>|   <span class="hljs-type">offset</span>  ]<br>...<br></code></pre></td></tr></table></figure><h2 id="超越物理内存"><a href="#超越物理内存" class="headerlink" title="超越物理内存"></a>超越物理内存</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>我们之前都是假设虚拟内存的空间地址小于物理内存的，为了支持运行更多更大的进程需要在内存层级（memory hierarchy）上加层。</p><p>在这里，我们考虑在物理内存下加上硬盘，并在硬盘上开辟交换空间。</p><p>为了支持交换空间，我们需要添加更多机制。比如在页表项添加存在位，表示该页是否在物理内存中。如果不在，会触发<strong>页错误</strong>。触发之后，会通过硬盘的I&#x2F;O来更新页表。注意在I&#x2F;O运行时，进程阻塞，此时可以执行其他进程，就是cpu虚拟化里提到的[[CPU虚拟化#overlap]]</p><p>同时，操作系统并非等到内存满才会交换页，实际上它可以主动预留一小部分内存。设置<strong>高水位线</strong>（HW）和<strong>低水位线</strong>（LW），当操作系统发现少于LW个页可用，会执行后台释放内存的进程直到有HW个页可用。</p><p>还有，通过同时执行多个交换过程，可以提高性能。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>为了效率，应该思考在页替换时的选择策略。</p><p><strong>最优替换策略</strong>：本质上需要可以预知未来。是一种无法实现，但可以作为参照（用于评估另一种算法好坏）的方法。具体是替换最远将来会访问的页（听着就很科幻）。</p><p><strong>FIFO</strong>：最先进入缓存的页out，缺点是其无法确定页的重要性。</p><p><strong>随机</strong>：看运气，也是不够智能</p><p><strong>LRU</strong>：可以通过历史记录，在执行替换时，踢出最少最近使用的页。</p><p><strong>近似LRU</strong>：LRU因为需要扫描所有页来实现替换，开销太大。以下是一种近似方法。给硬件增加使用位（use bit），每当页被引用时，使用位设置为1。我们采取<strong>时钟算法</strong>，当需要替换时，时钟指针检查当前指向的页的使用位，如果为1，则将其设置为0，并指向下一页，直到遇到使用位为0的页。</p><p>脏页。因为在内存中，一个没有修改过的页显然写回成本要小于修改过的（因为可以直接释放，不用进行I&#x2F;O）。所以可以考虑加一个脏位（dirty bit）。</p><p>还有一些策略：比如<strong>预取</strong>，<strong>聚集写入</strong>等。</p><h2 id="VAX-VMS"><a href="#VAX-VMS" class="headerlink" title="VAX&#x2F;VMS"></a>VAX&#x2F;VMS</h2><p>主要研究该操作系统的一些有意思的虚拟内存管理。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>内核虚拟空间是每个用户地址空间的一部分。在上下文切换时，该段的基址界限寄存器不会变，本质是将相同的地址空间映射到各个用户。</p><h3 id="页替换策略"><a href="#页替换策略" class="headerlink" title="页替换策略"></a>页替换策略</h3><p><strong>分段的FIFO的策略</strong>：每个进程都有一个可以保留在内存中的最大页数（resident set size），当超过RSS时，先入被驱逐。VMS还引入了二次机会列表（second- chance list），分别为一个全局干净列表和脏列表。页在被踢出之前放在这里。</p><p><strong>页聚集</strong>：将大批量的脏页分组到一起，并一举写入磁盘。</p><h3 id="惰性优化"><a href="#惰性优化" class="headerlink" title="惰性优化"></a>惰性优化</h3><p><strong>按需置零</strong>：当用户添加页到堆，（比如malloc），并不直接分配一个置零的页，而是只在页表里放入一个不可访问的条目。当用户需要读取或者写入该页，才会寻找物理页，将其置0并映射到地址空间。而如果进程不访问这页，就直接省去了这个开销。</p><p><strong>写时复制</strong>：若操作系统需要将一个页面从一个地址空间复制到另一个（比如fork），不会实际复制，而是将其映射到目标地址空间并标记为只读。当需要写的时候，才会分配新页填充数据并重新映射。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统：CPU虚拟化</title>
    <link href="/2024/08/30/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    <url>/2024/08/30/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h1><blockquote><p>线程简单理解：一个<strong>进程</strong>里可以有多个线程，线程可以看作小的进程。同一个进程下的线程共享全局变量和堆内存。</p></blockquote><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>现代操作系统lazily执行该过程，只有到需要时才会加载数据到进程的地址空间。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>拷贝父进程，但从fork开始执行。同时fork的返回值，子进程是0，父进程为子进程的pid。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h4><p>延迟进程的执行，直到子进程运行完毕才返回</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>并无创建子进程，而是将当前运行的程序替换为不同的运行程序。通过参数来重新初始化代码段、堆、栈等。</p><p>fork和exec的分开可以实现很多功能。shell：先找到可执行程序，接着fork新进程，在新进程里面exec程序，最后wait直到进程结束。比如shell的重定向。</p><p>如：<code>$ cat hello.c &gt; hello.txt</code>，在运行cat之前，先打开hello.txt，关闭stdout，然后再运行，就可以实现重定向。</p><h1 id="limited-direct-execution"><a href="#limited-direct-execution" class="headerlink" title="limited direct execution"></a>limited direct execution</h1><h2 id="限制操作"><a href="#限制操作" class="headerlink" title="限制操作"></a>限制操作</h2><p>为了让进程可以安全地在cpu上运行，引入不同的模式：</p><ul><li>user mode：行为受限</li><li>kernel mode：可以实现特权操作。<br>执行系统调用时，会通过<strong>trap</strong>来跳入内核并切换模式。通过内核启动时设置的<strong>trap table</strong>来跳转到相应的异常处理代码</li></ul><h2 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h2><h3 id="cooperative"><a href="#cooperative" class="headerlink" title="cooperative"></a>cooperative</h3><p>当应用程序结束、异常、运行时间过长，或者通过系统调用，控制权回归操作系统。（理想的程序）</p><h3 id="timer-interrupt"><a href="#timer-interrupt" class="headerlink" title="timer interrupt"></a>timer interrupt</h3><p>时钟为设备产生周期性的中断，控制权还给操作系统，让os决定接下来运行什么。</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>保存恢复上下文，即上下文切换。为当前的进程保存状态（寄存器etc），为接下来的进程恢复状态。注意与上文的中断不同，前者隐式保存用户的寄存器到该进程的内核栈，后者显示保存到该进程结构的内存（通过保存指针，来保存和恢复状态）（？）</p><h1 id="进程调度基础"><a href="#进程调度基础" class="headerlink" title="进程调度基础"></a>进程调度基础</h1><h2 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h2><p>对于每个进程：<br>周转时间 &#x3D; 完成时间 - 到达时间 （性能）<br>响应时间 &#x3D; 首次运行时间 - 到达时间（公平）</p><h2 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h2><p><strong>shortest job first</strong>，先运行最短时间的任务。对比FIFO的工作方式，周转时间降低。</p><h2 id="STCF"><a href="#STCF" class="headerlink" title="STCF"></a>STCF</h2><p><strong>shortest time-to-complete first</strong>，又称抢占式任务优先，每当有新工作加入系统，都会确定哪个工作的剩余时间最小，周转时间降低。</p><h2 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h2><p>轮转调度，将工作变成多个时间切片，循环执行不同工作的切片。时间片变短，响应时间越高，但相对的上下文切换的成本提高。公平和性能是一对需要权衡的因素，不可兼得。</p><h2 id="overlap"><a href="#overlap" class="headerlink" title="overlap"></a>overlap</h2><p>一个工作使用I&#x2F;O的时间，可以看成是独立于该工作。则另一个工作可以利用I&#x2F;O运行的时间。</p><h1 id="MLFQ"><a href="#MLFQ" class="headerlink" title="MLFQ"></a>MLFQ</h1><p><strong>multi-level feedback queue</strong>，多级反馈队列，其维护了多个优先级不同的队列，每个工作只存在于一个队列中，不同的队列有不同的时间配额，利用反馈的信息来决定工作的优先级。下面是其规则：</p><ul><li>A的优先级 &gt; B的优先级，则运行A而不运行B</li><li>A的优先级 &#x3D; B的优先级，则轮转运行A和B</li><li>工作进入系统时，放在最高优先级的队列</li><li>一旦工作用完了其在该队列的时间配额，就降低其优先级</li><li>经过一段时间S，所有工作重新加入最优先队列</li></ul><h1 id="proportional-share"><a href="#proportional-share" class="headerlink" title="proportional-share"></a>proportional-share</h1><p>比例份额调度</p><h2 id="lottery-share"><a href="#lottery-share" class="headerlink" title="lottery share"></a>lottery share</h2><p>进程运行越久，其彩票越多。在每次调度决策之前，都会抽出一个数字（中奖号码），显然，彩票越多的进程，中奖概率越大，则作为下一个运行的对象。该方法运用了随机性，当运行时间足够长时，不同工作的时间比例会趋于期望。实现上，比较轻量。</p><p>和LRU替换算法进行对比，LRU在遇到重复循环序列时，性能低。而彩票调度可以避免。</p><h2 id="stride-scheduling"><a href="#stride-scheduling" class="headerlink" title="stride scheduling"></a>stride scheduling</h2><p>步长调度，算法始终选择行程值最小的工作。严格实现，在每次调度都是正确的比例。</p><p>然而以上两种方法都不常用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Operating-System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Squeeze Compressor</title>
    <link href="/2024/08/30/Squeeze-Compressor/"/>
    <url>/2024/08/30/Squeeze-Compressor/</url>
    
    <content type="html"><![CDATA[<h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>核心的想法是：对于可精确预测的数据，通过曲线拟合；对于难以合适预测的数据，通过二进制表示的分析来进行有损压缩。</p><h2 id="implement"><a href="#implement" class="headerlink" title="implement"></a>implement</h2><p>压缩前需要的三个参数：绝对误差范围、相对误差范围、压缩率</p><p>以下是压缩的具体算法：</p><h3 id="convert-array"><a href="#convert-array" class="headerlink" title="convert array"></a>convert array</h3><p>通过实验发现，建立曲线是压缩中最大的时间开销。鉴于有<strong>较低的转换开销</strong>、<strong>良好地保留了局部性</strong>的两个优势，使用数据数组原来在内存中的序列用来压缩会更好。</p><h3 id="curve-fitting"><a href="#curve-fitting" class="headerlink" title="curve-fitting"></a>curve-fitting</h3><p>每个数据点都会检查其能否根据先前的数据，使用以下三种曲线近似方法的一种来表示，若可以，易知即可压缩成2bit的数据。</p><ul><li>PNF：通过前一个数据点的<strong>原数据</strong>来预测（01）</li><li>LCF：前两个数据点的<strong>原数据</strong>的线性估计（10）</li><li>QCF：通过前三个数据点的二次曲线来预测（11）</li><li>无法预测：（00）</li></ul><p>该部分会分为以下几步来实现：<br>假设有M个数据点</p><ul><li>分配2Mbits的内存，用于存放压缩后的数据</li><li>计算数据值的变化范围</li><li>检查数据点，决定近似方法，若可近似，将对应的编号写入内存处；若不可近似，则通过对二进制表示的分析来压缩，并写入另一个数组</li></ul><p>由以上的算法，可以看出，该部分的时间复杂度为O(n)，时间和数据量成线性关系十分优秀。</p><h3 id="binary-representation-analysis"><a href="#binary-representation-analysis" class="headerlink" title="binary representation analysis"></a>binary representation analysis</h3><p>以下是二进制表示分析的过程</p><ul><li>通过将所有数据减去中位数，产生<strong>规范化数据</strong>，以缩小数值的范围（可以用更少的位数来表示）</li><li>接着，在误差允许的范围内，抛弃部分影响不大的有效位，再计算需要多少位来表示（注意此处最小的单位为字节，需要将结果约成8的倍数）</li><li>最后，计算需要填充的0的数量，用2bits即可表示（单位为一个全0的字节）</li></ul><h2 id="further-explore"><a href="#further-explore" class="headerlink" title="further explore"></a>further explore</h2><p>SZ压缩提高了数据压缩的速度以及压缩率。可以应用于CPU、GPU、FPGA以及其他科研领域。上文只是SZ的最初实现（SZ 0.1-1.0)的算法。目前SZ以及更新到SZ 3.0了</p><h2 id="citations"><a href="#citations" class="headerlink" title="citations"></a>citations</h2><p>大部分内容来自于以下的论文：</p><ul><li>SZ 0.1-1.0: Sheng Di, Franck Cappello, “<a href="https://ieeexplore.ieee.org/document/7516069">Fast Error-bounded Lossy HPC Data Compression with SZ</a>“, in IEEE International Parallel and Distributed Processing Symposium (IPDPS 2016), Chicago, IL, USA, 2016.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>research</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test2</title>
    <link href="/2024/08/30/test2/"/>
    <url>/2024/08/30/test2/</url>
    
    <content type="html"><![CDATA[<h1 id="进行一些简单的测试"><a href="#进行一些简单的测试" class="headerlink" title="进行一些简单的测试"></a>进行一些简单的测试</h1><h2 id="标题测试"><a href="#标题测试" class="headerlink" title="标题测试"></a>标题测试</h2><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h2 id="代码块测试"><a href="#代码块测试" class="headerlink" title="代码块测试"></a>代码块测试</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">hello, world!<br></code></pre></td></tr></table></figure><h2 id="列表测试"><a href="#列表测试" class="headerlink" title="列表测试"></a>列表测试</h2><ul><li>1</li><li>2</li><li>3</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><p>$$<br>x &#x3D; 1<br>$$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/08/29/hello-world/"/>
    <url>/2024/08/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>It starts here.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
